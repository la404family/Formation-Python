#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
======================================================================
√âCRITURE DE FICHIERS EN PYTHON - GUIDE COMPLET
======================================================================

üéØ Ce fichier couvre l'√©criture de fichiers en d√©tail :
   ‚Ä¢ Modes d'√©criture et cr√©ation
   ‚Ä¢ M√©thodes write() et writelines()
   ‚Ä¢ Gestion du buffering et flush
   ‚Ä¢ √âcriture s√©curis√©e avec context managers
   ‚Ä¢ Formats texte et binaire
   ‚Ä¢ G√©n√©ration de fichiers structur√©s

üìö Concepts abord√©s :
   ‚Ä¢ Cr√©ation et √©crasement de fichiers
   ‚Ä¢ Ajout et modification
   ‚Ä¢ Encodage et caract√®res sp√©ciaux
   ‚Ä¢ Performance et optimisation
   ‚Ä¢ Validation et int√©grit√©
   ‚Ä¢ Patterns d'√©criture avanc√©s

üí° Objectif : Ma√Ætriser l'√©criture efficace et s√©curis√©e
"""

import os
print("=" * 70)
print("√âCRITURE DE FICHIERS EN PYTHON - GUIDE COMPLET")
print("=" * 70)

print("\n" + "=" * 50)
print("1. FONDAMENTAUX DE L'√âCRITURE")
print("=" * 50)

print("\nüìù QU'EST-CE QUE L'√âCRITURE DE FICHIERS ?")
print("-" * 43)

print("""
üéØ D√âFINITION :
L'√©criture de fichiers consiste √† cr√©er ou modifier des fichiers
en y stockant des donn√©es sous forme d'octets ou de caract√®res.

üîÑ OP√âRATIONS D'√âCRITURE :
‚Ä¢ Cr√©ation : cr√©er un nouveau fichier
‚Ä¢ √âcrasement : remplacer compl√®tement un fichier existant
‚Ä¢ Ajout : ajouter du contenu √† la fin d'un fichier
‚Ä¢ Insertion : modifier une partie sp√©cifique (complexe)
‚Ä¢ Atomique : √©criture s√©curis√©e sans corruption

‚ö° CONSID√âRATIONS IMPORTANTES :
‚Ä¢ Permissions du syst√®me de fichiers
‚Ä¢ Espace disque disponible
‚Ä¢ Encodage des caract√®res
‚Ä¢ Performance et buffering
‚Ä¢ Int√©grit√© et s√©curit√© des donn√©es
‚Ä¢ Concurrent access et verrouillage
""")

print("\nüé≠ MODES D'√âCRITURE")
print("-" * 19)

modes_ecriture = [
    ("'w'", "√âcriture seule", "Cr√©e/√©crase le fichier", "Pointeur au d√©but"),
    ("'w+'", "Lecture/√©criture", "Cr√©e/√©crase le fichier", "Pointeur au d√©but"),
    ("'a'", "Ajout seul", "Cr√©e si n√©cessaire", "Pointeur √† la fin"),
    ("'a+'", "Lecture/ajout", "Cr√©e si n√©cessaire", "Pointeur √† la fin"),
    ("'x'", "Cr√©ation exclusive", "√âchoue si existe d√©j√†", "Pointeur au d√©but"),
    ("'x+'", "Cr√©ation + lecture", "√âchoue si existe d√©j√†", "Pointeur au d√©but"),
]

print("üé≠ Modes d'√©criture disponibles :")
for mode, nom, comportement, pointeur in modes_ecriture:
    print(f"   {mode:<6} : {nom:<18} | {comportement:<20} | {pointeur}")

print("\nüî§ MODIFICATEURS")
print("-" * 15)

print("""
üî§ MODIFICATEURS DE MODE :
‚Ä¢ 'b' : Mode binaire (octets bruts)
‚Ä¢ 't' : Mode texte (d√©faut, avec encodage)

üìù EXEMPLES COMPLETS :
‚Ä¢ 'w'  = 'wt' : √©criture texte avec √©crasement
‚Ä¢ 'wb'        : √©criture binaire avec √©crasement
‚Ä¢ 'a'  = 'at' : ajout texte
‚Ä¢ 'ab'        : ajout binaire
‚Ä¢ 'x'  = 'xt' : cr√©ation exclusive texte
‚Ä¢ 'xb'        : cr√©ation exclusive binaire

‚ö†Ô∏è ATTENTION :
Mode 'w' √©crase compl√®tement le fichier !
Mode 'x' √©choue si le fichier existe d√©j√†.
""")


# Cr√©er le r√©pertoire output s'il n'existe pas
os.makedirs("output_files", exist_ok=True)

print("\nüìÅ R√©pertoire 'output_files/' cr√©√© pour les tests")

print("\n" + "=" * 50)
print("2. M√âTHODES D'√âCRITURE DE BASE")
print("=" * 50)

print("\n‚úçÔ∏è WRITE() - √âCRITURE DE CHA√éNES")
print("-" * 32)


def demo_write_basique():
    """D√©monstration de la m√©thode write()"""

    print("‚úçÔ∏è √âcriture basique avec write() :")

    try:
        # √âcriture simple
        with open("output_files/demo_write.txt", "w", encoding="utf-8") as f:
            # write() retourne le nombre de caract√®res √©crits
            nb_chars = f.write("Bonjour le monde !\n")
            print(f"   √âcrit : {nb_chars} caract√®res")

            # √âcriture multiple
            lignes = [
                "Premi√®re ligne de texte\n",
                "Deuxi√®me ligne avec des accents : √©√†√π√ß\n",
                "Troisi√®me ligne avec des chiffres : 12345\n",
                "Derni√®re ligne sans retour √† la ligne"
            ]

            total_chars = 0
            for i, ligne in enumerate(lignes, 1):
                nb = f.write(ligne)
                total_chars += nb
                print(f"   Ligne {i} : {nb} caract√®res")

            print(f"   Total √©crit : {total_chars} caract√®res")

        # V√©rification
        with open("output_files/demo_write.txt", "r", encoding="utf-8") as f:
            contenu = f.read()
            print(f"\n   V√©rification - Contenu √©crit :")
            for i, ligne in enumerate(contenu.split('\n'), 1):
                print(f"      [{i}] : '{ligne}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_write_basique()

print("\nüìù WRITELINES() - √âCRITURE DE LISTES")
print("-" * 36)


def demo_writelines():
    """D√©monstration de la m√©thode writelines()"""

    print("üìù √âcriture de listes avec writelines() :")

    try:
        # Pr√©parer des donn√©es
        donnees = [
            "# Configuration de l'application\n",
            "version = 1.0\n",
            "debug = True\n",
            "\n",  # Ligne vide
            "# Base de donn√©es\n",
            "db_host = localhost\n",
            "db_port = 5432\n",
            "db_name = myapp\n"
        ]

        # √âcriture avec writelines()
        with open("output_files/config.txt", "w", encoding="utf-8") as f:
            f.writelines(donnees)
            print(f"   √âcrit {len(donnees)} lignes avec writelines()")

        # Comparaison avec write() en boucle
        with open("output_files/config_alt.txt", "w", encoding="utf-8") as f:
            for ligne in donnees:
                f.write(ligne)
            print(f"   √âcrit {len(donnees)} lignes avec write() en boucle")

        # V√©rification de l'identit√©
        with open("output_files/config.txt", "r", encoding="utf-8") as f1:
            contenu1 = f1.read()
        with open("output_files/config_alt.txt", "r", encoding="utf-8") as f2:
            contenu2 = f2.read()

        print(f"   Contenus identiques : {contenu1 == contenu2}")
        print(f"   Taille : {len(contenu1)} caract√®res")

        # Attention : writelines() n'ajoute PAS de retours √† la ligne !
        print("\n   ‚ö†Ô∏è D√©monstration du pi√®ge writelines() :")
        donnees_sans_newline = ["ligne1", "ligne2", "ligne3"]

        with open("output_files/piege.txt", "w", encoding="utf-8") as f:
            f.writelines(donnees_sans_newline)

        with open("output_files/piege.txt", "r", encoding="utf-8") as f:
            contenu_piege = f.read()
            print(f"   R√©sultat : '{contenu_piege}'")  # Tout sur une ligne !

        # Correction
        with open("output_files/corrige.txt", "w", encoding="utf-8") as f:
            f.writelines(ligne + "\n" for ligne in donnees_sans_newline)

        with open("output_files/corrige.txt", "r", encoding="utf-8") as f:
            contenu_corrige = f.read()
            print(f"   Corrig√© : '{contenu_corrige.replace(chr(10), '\\n')}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_writelines()

print("\nüñ®Ô∏è PRINT() VERS FICHIERS")
print("-" * 24)


def demo_print_vers_fichier():
    """Utilisation de print() pour √©crire dans des fichiers"""

    print("üñ®Ô∏è √âcriture avec print() :")

    try:
        with open("output_files/demo_print.txt", "w", encoding="utf-8") as f:
            # print() vers fichier avec file=
            print("Utilisation de print() pour √©crire", file=f)
            print("Deuxi√®me ligne", file=f)
            print(file=f)  # Ligne vide

            # Avec des param√®tres
            print("Valeurs :", 1, 2, 3, sep=", ", file=f)
            print("Sans retour √† la ligne", end="", file=f)
            print(" (suite sur la m√™me ligne)", file=f)

            # Formatage
            nom = "Alice"
            age = 25
            print(f"Utilisateur : {nom}, √¢ge : {age}", file=f)

            # Avec des objets complexes
            donnees = {"nom": "Bob", "scores": [85, 92, 78]}
            print("Donn√©es :", donnees, file=f)

        # V√©rification
        with open("output_files/demo_print.txt", "r", encoding="utf-8") as f:
            print("\n   üìñ Contenu g√©n√©r√© par print() :")
            for i, ligne in enumerate(f, 1):
                print(f"      [{i}] : {ligne.rstrip()}")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_print_vers_fichier()

print("\n" + "=" * 50)
print("3. MODES D'√âCRITURE AVANC√âS")
print("=" * 50)

print("\nüéØ MODE 'W' - √âCRASEMENT")
print("-" * 24)


def demo_mode_w():
    """D√©monstration du mode 'w' (√©crasement)"""

    print("üéØ Mode 'w' - √âcrasement complet :")

    try:
        # Cr√©er un fichier initial
        with open("output_files/test_ecrasement.txt", "w", encoding="utf-8") as f:
            f.write("Contenu initial\nLigne 2\nLigne 3\n")

        print("   üìù Fichier initial cr√©√©")

        # Lire le contenu initial
        with open("output_files/test_ecrasement.txt", "r", encoding="utf-8") as f:
            contenu_initial = f.read()
            print(f"   üìñ Contenu initial : {len(contenu_initial)} caract√®res")
            print(f"      '{contenu_initial.replace(chr(10), '\\n')}'")

        # √âcraser avec du nouveau contenu (plus court)
        with open("output_files/test_ecrasement.txt", "w", encoding="utf-8") as f:
            f.write("Nouveau contenu")

        print("   üîÑ Fichier √©cras√©")

        # V√©rifier l'√©crasement
        with open("output_files/test_ecrasement.txt", "r", encoding="utf-8") as f:
            contenu_final = f.read()
            print(f"   üìñ Contenu final : {len(contenu_final)} caract√®res")
            print(f"      '{contenu_final}'")

        print("   ‚ö†Ô∏è L'ancien contenu a √©t√© compl√®tement perdu !")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_mode_w()

print("\n‚ûï MODE 'A' - AJOUT")
print("-" * 19)


def demo_mode_a():
    """D√©monstration du mode 'a' (ajout)"""

    print("‚ûï Mode 'a' - Ajout en fin de fichier :")

    try:
        # Cr√©er un fichier initial
        with open("output_files/test_ajout.txt", "w", encoding="utf-8") as f:
            f.write("Ligne initiale 1\nLigne initiale 2\n")

        print("   üìù Fichier initial cr√©√©")

        # Ajouter du contenu plusieurs fois
        for i in range(3):
            with open("output_files/test_ajout.txt", "a", encoding="utf-8") as f:
                f.write(f"Ligne ajout√©e {i+1}\n")
            print(f"   ‚ûï Ajout {i+1} effectu√©")

        # V√©rifier le r√©sultat
        with open("output_files/test_ajout.txt", "r", encoding="utf-8") as f:
            lignes = f.readlines()
            print(f"   üìñ Fichier final : {len(lignes)} lignes")
            for i, ligne in enumerate(lignes, 1):
                print(f"      [{i:2d}] : {ligne.rstrip()}")

        # D√©montrer que le pointeur est toujours en fin
        print("\n   üìç Position du pointeur en mode 'a' :")
        with open("output_files/test_ajout.txt", "a", encoding="utf-8") as f:
            print(f"      Position √† l'ouverture : {f.tell()}")
            f.write("Test position")
            print(f"      Position apr√®s √©criture : {f.tell()}")

            # M√™me si on essaie de se d√©placer...
            f.seek(0)
            print(f"      Position apr√®s seek(0) : {f.tell()}")
            f.write(" - Ceci sera ajout√© √† la fin !")
            print(f"      Position finale : {f.tell()}")

        # V√©rifier que l'√©criture s'est bien faite √† la fin
        with open("output_files/test_ajout.txt", "r", encoding="utf-8") as f:
            contenu = f.read()
            print(f"   üìñ Derni√®re ligne : '{contenu.splitlines()[-1]}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_mode_a()

print("\nüö´ MODE 'X' - CR√âATION EXCLUSIVE")
print("-" * 32)


def demo_mode_x():
    """D√©monstration du mode 'x' (cr√©ation exclusive)"""

    print("üö´ Mode 'x' - Cr√©ation exclusive :")

    # Nettoyer d'abord
    fichier_test = "output_files/test_exclusif.txt"
    if os.path.exists(fichier_test):
        os.remove(fichier_test)

    try:
        # Premi√®re cr√©ation - doit r√©ussir
        print("   1Ô∏è‚É£ Premi√®re tentative de cr√©ation :")
        with open(fichier_test, "x", encoding="utf-8") as f:
            f.write("Fichier cr√©√© en mode exclusif\n")
            f.write("Cr√©ation r√©ussie !\n")
        print("      ‚úÖ Cr√©ation r√©ussie")

        # Deuxi√®me tentative - doit √©chouer
        print("   2Ô∏è‚É£ Deuxi√®me tentative (fichier existe) :")
        try:
            with open(fichier_test, "x", encoding="utf-8") as f:
                f.write("Ceci ne devrait pas s'√©crire")
            print("      ‚ùå Erreur : cr√©ation r√©ussie alors qu'elle devrait √©chouer")
        except FileExistsError as e:
            print(f"      ‚úÖ √âchec attendu : {e}")

        # V√©rifier le contenu original
        with open(fichier_test, "r", encoding="utf-8") as f:
            contenu = f.read()
            print(f"   üìñ Contenu pr√©serv√© : '{contenu.replace(chr(10), '\\n')}'")

        # Cas d'usage typique : √©viter l'√©crasement accidentel
        print("\n   üí° Cas d'usage - Fichier de sauvegarde unique :")
        import datetime

        for i in range(3):
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            nom_sauvegarde = f"output_files/sauvegarde_{timestamp}_{i}.txt"

            try:
                with open(nom_sauvegarde, "x", encoding="utf-8") as f:
                    f.write(f"Sauvegarde cr√©√©e le {timestamp}\n")
                    f.write(f"Tentative num√©ro {i+1}\n")
                print(f"      ‚úÖ Sauvegarde cr√©√©e : {nom_sauvegarde}")
            except FileExistsError:
                print(f"      ‚ö†Ô∏è Sauvegarde existe d√©j√† : {nom_sauvegarde}")

    except Exception as e:
        print(f"   ‚ùå Erreur inattendue : {e}")


demo_mode_x()

print("\nüîÑ MODES COMBIN√âS (+ LECTURE)")
print("-" * 30)


def demo_modes_combines():
    """D√©monstration des modes combin√©s lecture/√©criture"""

    print("üîÑ Modes combin√©s lecture/√©criture :")

    try:
        # Mode 'w+' : √©criture + lecture avec √©crasement
        print("   Mode 'w+' :")
        with open("output_files/test_w_plus.txt", "w+", encoding="utf-8") as f:
            # √âcrire
            f.write("Ligne 1\nLigne 2\nLigne 3\n")
            print(f"      Position apr√®s √©criture : {f.tell()}")

            # Lire depuis le d√©but
            f.seek(0)
            contenu = f.read()
            print(f"      Contenu lu : {len(contenu.splitlines())} lignes")

            # Ajouter √† la fin
            f.write("Ligne 4 ajout√©e\n")

            # Relire tout
            f.seek(0)
            contenu_final = f.read()
            print(
                f"      Contenu final : {len(contenu_final.splitlines())} lignes")

        # Mode 'a+' : ajout + lecture
        print("\n   Mode 'a+' :")
        # D'abord cr√©er un fichier
        with open("output_files/test_a_plus.txt", "w", encoding="utf-8") as f:
            f.write("Contenu initial\n")

        with open("output_files/test_a_plus.txt", "a+", encoding="utf-8") as f:
            print(f"      Position initiale : {f.tell()}")

            # Lire le contenu existant
            f.seek(0)
            contenu_existant = f.read()
            print(f"      Contenu existant : '{contenu_existant.rstrip()}'")

            # Ajouter du nouveau contenu
            f.write("Contenu ajout√©\n")

            # Relire tout
            f.seek(0)
            contenu_complet = f.read()
            print(
                f"      Contenu complet : {len(contenu_complet.splitlines())} lignes")

        # Mode 'r+' : lecture/√©criture sans √©crasement
        print("\n   Mode 'r+' :")
        with open("output_files/test_a_plus.txt", "r+", encoding="utf-8") as f:
            # Lire
            lignes = f.readlines()
            print(f"      Lignes lues : {len(lignes)}")

            # Modifier une ligne (√©craser en place)
            f.seek(0)
            f.write("MODIFI√â: " + lignes[0])

            # Voir le r√©sultat
            f.seek(0)
            nouveau_contenu = f.read()
            print(f"      Apr√®s modification : '{nouveau_contenu.replace(chr(10), '\\n')}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_modes_combines()

print("\n" + "=" * 50)
print("4. BUFFERING ET PERFORMANCE")
print("=" * 50)

print("\n‚ö° BUFFERING - CONCEPT")
print("-" * 21)

print("""
‚ö° QU'EST-CE QUE LE BUFFERING ?
Le buffering consiste √† stocker temporairement les donn√©es
en m√©moire avant de les √©crire physiquement sur le disque.

üéØ AVANTAGES :
‚Ä¢ Performance : moins d'acc√®s disque
‚Ä¢ Efficacit√© : √©critures group√©es
‚Ä¢ Syst√®me : optimisation OS

üìä TYPES DE BUFFERING :
‚Ä¢ Ligne par ligne (line buffering)
‚Ä¢ Bloc fixe (block buffering)
‚Ä¢ Pas de buffering (unbuffered)

‚ö†Ô∏è RISQUES :
‚Ä¢ Perte de donn√©es si crash avant flush
‚Ä¢ Latence pour voir les changements
‚Ä¢ Consommation m√©moire
""")


def demo_buffering():
    """D√©monstration de l'impact du buffering"""
    import time

    print("‚ö° D√©monstration du buffering :")

    # Cr√©er un fichier avec buffering par d√©faut
    print("   1Ô∏è‚É£ √âcriture avec buffering par d√©faut :")
    with open("output_files/test_buffer_default.txt", "w", encoding="utf-8") as f:
        for i in range(5):
            f.write(f"Ligne {i+1} √©crite\n")
            print(f"      √âcrit ligne {i+1}")

            # V√©rifier si visible imm√©diatement (autre processus)
            # En pratique, on ne verrait pas les changements imm√©diatement
            time.sleep(0.1)

    print("      ‚úÖ Fichier ferm√© - tout est maintenant sur disque")

    # √âcriture sans buffering
    print("\n   2Ô∏è‚É£ √âcriture sans buffering :")
    with open("output_files/test_buffer_none.txt", "w", encoding="utf-8", buffering=0) as f:
        # Note: buffering=0 n'est possible qu'en mode binaire
        pass

    # En mode texte, utiliser buffering=1 (ligne par ligne)
    print("   3Ô∏è‚É£ √âcriture ligne par ligne (buffering=1) :")
    with open("output_files/test_buffer_line.txt", "w", encoding="utf-8", buffering=1) as f:
        for i in range(3):
            f.write(f"Ligne {i+1}")  # Pas de \n
            print(f"      √âcrit 'Ligne {i+1}' (pas encore sur disque)")

            f.write("\n")  # Maintenant √ßa flush !
            print(f"      Ajout√© \\n (maintenant sur disque)")
            time.sleep(0.1)

    # Buffering manuel avec flush
    print("\n   4Ô∏è‚É£ Contr√¥le manuel avec flush() :")
    with open("output_files/test_buffer_manuel.txt", "w", encoding="utf-8") as f:
        f.write("Donn√©es importantes")
        print("      √âcrit en buffer, pas encore sur disque")

        f.flush()  # Forcer l'√©criture sur disque
        print("      flush() appel√© - maintenant sur disque")

        f.write(" - suite des donn√©es")
        print("      Suite √©crite en buffer")

        # Le close() automatique √† la fin du with fera le flush final


print()
demo_buffering()

print("\nüöÄ FLUSH() - CONTR√îLE MANUEL")
print("-" * 27)


def demo_flush():
    """D√©monstration de flush() pour contr√¥le pr√©cis"""
    import time

    print("üöÄ Contr√¥le pr√©cis avec flush() :")

    try:
        with open("output_files/demo_flush.txt", "w", encoding="utf-8") as f:
            # √âcriture critique qui doit √™tre sauv√©e imm√©diatement
            f.write("=== D√âBUT DE SESSION ===\n")
            f.write(f"Timestamp: {time.time()}\n")
            f.flush()  # Sauvegarder imm√©diatement
            print("   ‚úÖ En-t√™te de session sauvegard√©")

            # Simulation d'op√©rations avec sauvegarde p√©riodique
            for i in range(10):
                f.write(f"Op√©ration {i+1} en cours...\n")

                # Sauvegarder toutes les 3 op√©rations
                if (i+1) % 3 == 0:
                    f.flush()
                    print(f"   üíæ Sauvegarde apr√®s op√©ration {i+1}")

                time.sleep(0.05)  # Simulation de travail

            # Fin de session
            f.write("=== FIN DE SESSION ===\n")
            f.flush()
            print("   ‚úÖ Fin de session sauvegard√©e")

        # V√©rifier le contenu
        with open("output_files/demo_flush.txt", "r", encoding="utf-8") as f:
            lignes = f.readlines()
            print(f"   üìä Fichier final : {len(lignes)} lignes")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_flush()

print("\nüìà PERFORMANCE COMPARISONS")
print("-" * 27)


def comparer_performances_ecriture():
    """Comparaison des performances d'√©criture"""
    import time

    print("üìà Comparaison des performances :")

    nb_lignes = 10000
    donnees = [
        f"Ligne de test num√©ro {i:05d} avec du contenu\n" for i in range(nb_lignes)]

    # Test 1 : √âcriture une par une avec flush
    start_time = time.time()
    with open("output_files/perf_flush_chaque.txt", "w", encoding="utf-8") as f:
        for ligne in donnees:
            f.write(ligne)
            f.flush()  # Flush apr√®s chaque ligne (lent !)
    duree_flush_chaque = time.time() - start_time

    # Test 2 : √âcriture une par une sans flush
    start_time = time.time()
    with open("output_files/perf_sans_flush.txt", "w", encoding="utf-8") as f:
        for ligne in donnees:
            f.write(ligne)
    duree_sans_flush = time.time() - start_time

    # Test 3 : √âcriture en une fois avec writelines
    start_time = time.time()
    with open("output_files/perf_writelines.txt", "w", encoding="utf-8") as f:
        f.writelines(donnees)
    duree_writelines = time.time() - start_time

    # Test 4 : √âcriture par blocs
    start_time = time.time()
    with open("output_files/perf_par_blocs.txt", "w", encoding="utf-8") as f:
        taille_bloc = 1000
        for i in range(0, len(donnees), taille_bloc):
            bloc = donnees[i:i+taille_bloc]
            f.writelines(bloc)
            f.flush()
    duree_par_blocs = time.time() - start_time

    # Affichage des r√©sultats
    print(f"   üìä R√©sultats pour {nb_lignes:,} lignes :")
    print(f"      Flush chaque ligne : {duree_flush_chaque:.3f}s (tr√®s lent)")
    print(f"      Sans flush manuel  : {duree_sans_flush:.3f}s")
    print(f"      Writelines()       : {duree_writelines:.3f}s (rapide)")
    print(f"      Par blocs (1000)   : {duree_par_blocs:.3f}s")

    # Calculer les ratios
    if duree_writelines > 0:
        ratio_flush = duree_flush_chaque / duree_writelines
        ratio_sans = duree_sans_flush / duree_writelines
        ratio_blocs = duree_par_blocs / duree_writelines

        print(f"\n   üìà Ratios par rapport √† writelines() :")
        print(f"      Flush chaque : {ratio_flush:.1f}x plus lent")
        print(f"      Sans flush   : {ratio_sans:.1f}x")
        print(f"      Par blocs    : {ratio_blocs:.1f}x")


comparer_performances_ecriture()

print("\n" + "=" * 50)
print("5. √âCRITURE S√âCURIS√âE")
print("=" * 50)

print("\nüõ°Ô∏è √âCRITURE ATOMIQUE")
print("-" * 21)


def ecriture_atomique(nom_fichier, donnees):
    """√âcriture atomique pour √©viter la corruption"""
    import tempfile
    import shutil

    print(f"üõ°Ô∏è √âcriture atomique de '{nom_fichier}' :")

    try:
        # Cr√©er un fichier temporaire dans le m√™me r√©pertoire
        repertoire = os.path.dirname(nom_fichier) or "."

        with tempfile.NamedTemporaryFile(
            mode='w',
            encoding='utf-8',
            dir=repertoire,
            delete=False,
            suffix='.tmp'
        ) as temp_file:

            temp_nom = temp_file.name
            print(f"   üìù √âcriture dans fichier temporaire : {temp_nom}")

            # √âcrire toutes les donn√©es
            if isinstance(donnees, str):
                temp_file.write(donnees)
            elif isinstance(donnees, list):
                temp_file.writelines(donnees)
            else:
                temp_file.write(str(donnees))

            # S'assurer que tout est √©crit
            temp_file.flush()
            os.fsync(temp_file.fileno())  # Force sync to disk

        # Maintenant d√©placer atomiquement
        shutil.move(temp_nom, nom_fichier)
        print(f"   ‚úÖ Fichier d√©plac√© atomiquement vers {nom_fichier}")

        return True

    except Exception as e:
        print(f"   ‚ùå Erreur lors de l'√©criture atomique : {e}")

        # Nettoyer le fichier temporaire si n√©cessaire
        try:
            if os.path.exists(temp_nom):
                os.remove(temp_nom)
        except:
            pass

        return False


# Test de l'√©criture atomique
donnees_test = [
    "Donn√©es critiques ligne 1\n",
    "Donn√©es critiques ligne 2\n",
    "Configuration importante\n",
    "Ne doit jamais √™tre corrompue\n"
]

ecriture_atomique("output_files/donnees_critiques.txt", donnees_test)

print("\nüîê GESTION DES PERMISSIONS")
print("-" * 26)


def demo_permissions():
    """D√©monstration de la gestion des permissions"""
    import stat

    print("üîê Gestion des permissions de fichiers :")

    try:
        # Cr√©er un fichier avec permissions par d√©faut
        nom_fichier = "output_files/test_permissions.txt"
        with open(nom_fichier, "w", encoding="utf-8") as f:
            f.write("Fichier de test pour permissions\n")

        # V√©rifier les permissions actuelles
        permissions_actuelles = oct(os.stat(nom_fichier).st_mode)[-3:]
        print(f"   üìä Permissions actuelles : {permissions_actuelles}")

        # Modifier les permissions (lecture seule pour le propri√©taire)
        os.chmod(nom_fichier, stat.S_IRUSR)
        nouvelles_permissions = oct(os.stat(nom_fichier).st_mode)[-3:]
        print(
            f"   üîí Nouvelles permissions : {nouvelles_permissions} (lecture seule)")

        # Tenter d'√©crire (devrait √©chouer)
        try:
            with open(nom_fichier, "a", encoding="utf-8") as f:
                f.write("Tentative d'ajout\n")
            print("   ‚ùå Erreur : √©criture r√©ussie alors qu'elle devrait √©chouer")
        except PermissionError as e:
            print(f"   ‚úÖ Erreur de permission attendue : {e}")

        # Restaurer les permissions d'√©criture
        os.chmod(nom_fichier, stat.S_IRUSR | stat.S_IWUSR)
        permissions_finales = oct(os.stat(nom_fichier).st_mode)[-3:]
        print(f"   üîì Permissions restaur√©es : {permissions_finales}")

        # Maintenant l'√©criture devrait marcher
        with open(nom_fichier, "a", encoding="utf-8") as f:
            f.write("Ajout apr√®s restauration des permissions\n")
        print("   ‚úÖ √âcriture r√©ussie apr√®s restauration")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_permissions()

print("\nüîí VERROUILLAGE DE FICHIERS")
print("-" * 28)


def demo_verrouillage():
    """D√©monstration du verrouillage de fichiers"""
    import fcntl
    import time
    import threading

    print("üîí Verrouillage de fichiers :")

    def ecrire_avec_verrou(nom_fichier, contenu, delai=1):
        """√âcrire dans un fichier avec verrouillage"""
        try:
            with open(nom_fichier, "a", encoding="utf-8") as f:
                print(
                    f"   üîê Tentative de verrouillage par thread {threading.current_thread().name}")

                # Verrouiller le fichier (Unix/Linux uniquement)
                if hasattr(fcntl, 'flock'):
                    fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                    print(
                        f"   ‚úÖ Verrou acquis par {threading.current_thread().name}")

                # Simuler du travail
                f.write(f"=== D√âBUT {threading.current_thread().name} ===\n")
                time.sleep(delai)
                f.write(contenu)
                f.write(f"=== FIN {threading.current_thread().name} ===\n\n")

                print(
                    f"   üìù √âcriture termin√©e par {threading.current_thread().name}")

                # Le verrou sera lib√©r√© automatiquement √† la fermeture

        except Exception as e:
            print(f"   ‚ùå Erreur dans {threading.current_thread().name} : {e}")

    # Test sur syst√®mes supportant fcntl
    try:
        import fcntl

        # Nettoyer le fichier de test
        nom_fichier = "output_files/test_verrou.txt"
        if os.path.exists(nom_fichier):
            os.remove(nom_fichier)

        # Cr√©er plusieurs threads qui √©crivent simultan√©ment
        threads = []
        for i in range(3):
            contenu = f"Contenu du thread {i+1}\nLigne 2 du thread {i+1}\n"
            thread = threading.Thread(
                target=ecrire_avec_verrou,
                args=(nom_fichier, contenu, 0.5),
                name=f"Thread-{i+1}"
            )
            threads.append(thread)

        # Lancer tous les threads
        for thread in threads:
            thread.start()

        # Attendre que tous finissent
        for thread in threads:
            thread.join()

        # V√©rifier le r√©sultat
        if os.path.exists(nom_fichier):
            with open(nom_fichier, "r", encoding="utf-8") as f:
                contenu = f.read()
                print(
                    f"   üìñ Contenu final ({len(contenu.splitlines())} lignes) :")
                # Premiers 10 lignes
                for i, ligne in enumerate(contenu.splitlines()[:10], 1):
                    print(f"      [{i:2d}] : {ligne}")

    except ImportError:
        print("   ‚ö†Ô∏è fcntl non disponible sur ce syst√®me (Windows)")
        print("   üí° Utiliser des solutions alternatives comme filelock")


demo_verrouillage()

print("\n" + "=" * 50)
print("6. FORMATS SP√âCIALIS√âS")
print("=" * 50)

print("\nüìä G√âN√âRATION DE CSV")
print("-" * 20)


def generer_csv():
    """G√©n√©ration de fichiers CSV"""
    import csv

    print("üìä G√©n√©ration de fichiers CSV :")

    # Donn√©es de test
    employes = [
        {"nom": "Dupont", "prenom": "Jean", "age": 30,
            "salaire": 35000, "departement": "IT"},
        {"nom": "Martin", "prenom": "Marie", "age": 25,
            "salaire": 32000, "departement": "RH"},
        {"nom": "Durand", "prenom": "Pierre", "age": 35,
            "salaire": 42000, "departement": "Finance"},
        {"nom": "Dubois", "prenom": "Sophie", "age": 28,
            "salaire": 38000, "departement": "Marketing"},
        {"nom": "Leroy", "prenom": "Paul", "age": 45,
            "salaire": 55000, "departement": "Direction"},
    ]

    # M√©thode 1 : CSV manuel
    print("   1Ô∏è‚É£ G√©n√©ration CSV manuelle :")
    with open("output_files/employes_manuel.csv", "w", encoding="utf-8") as f:
        # En-t√™te
        f.write("nom,prenom,age,salaire,departement\n")

        # Donn√©es
        for emp in employes:
            ligne = f"{emp['nom']},{emp['prenom']},{emp['age']},{emp['salaire']},{emp['departement']}\n"
            f.write(ligne)

    print("      ‚úÖ CSV manuel g√©n√©r√©")

    # M√©thode 2 : Module CSV (recommand√©)
    print("   2Ô∏è‚É£ G√©n√©ration avec module CSV :")
    with open("output_files/employes_module.csv", "w", encoding="utf-8", newline='') as f:
        writer = csv.DictWriter(
            f, fieldnames=["nom", "prenom", "age", "salaire", "departement"])

        # En-t√™te
        writer.writeheader()

        # Donn√©es
        writer.writerows(employes)

    print("      ‚úÖ CSV avec module g√©n√©r√©")

    # M√©thode 3 : CSV avec caract√®res sp√©ciaux (√©chappement)
    print("   3Ô∏è‚É£ CSV avec caract√®res sp√©ciaux :")
    donnees_speciales = [
        {"nom": "O'Connor", "commentaire": "Tr√®s bien, \"excellent\" travail", "note": "A+"},
        {"nom": "M√ºller", "commentaire": "Contient des , virgules", "note": "B"},
        {"nom": "Jos√©", "commentaire": "Multiline\ncomment", "note": "A"},
    ]

    with open("output_files/donnees_speciales.csv", "w", encoding="utf-8", newline='') as f:
        writer = csv.DictWriter(f, fieldnames=["nom", "commentaire", "note"])
        writer.writeheader()
        writer.writerows(donnees_speciales)

    print("      ‚úÖ CSV avec √©chappement g√©n√©r√©")

    # V√©rification
    print("\n   üìñ V√©rification du CSV avec √©chappement :")
    with open("output_files/donnees_speciales.csv", "r", encoding="utf-8") as f:
        contenu = f.read()
        for i, ligne in enumerate(contenu.splitlines(), 1):
            print(f"      [{i}] : {ligne}")


generer_csv()

print("\nüîß G√âN√âRATION DE JSON")
print("-" * 21)


def generer_json():
    """G√©n√©ration de fichiers JSON"""
    import json
    from datetime import datetime, date

    print("üîß G√©n√©ration de fichiers JSON :")

    # Donn√©es complexes
    donnees = {
        "application": {
            "nom": "MonApp",
            "version": "2.1.0",
            "date_release": "2024-01-15"
        },
        "utilisateurs": [
            {
                "id": 1,
                "nom": "Alice",
                "email": "alice@example.com",
                "actif": True,
                "derniere_connexion": "2024-01-14T10:30:00Z",
                "preferences": {
                    "theme": "sombre",
                    "notifications": True,
                    "langue": "fr"
                }
            },
            {
                "id": 2,
                "nom": "Bob",
                "email": "bob@example.com",
                "actif": False,
                "derniere_connexion": None,
                "preferences": {
                    "theme": "clair",
                    "notifications": False,
                    "langue": "en"
                }
            }
        ],
        "statistiques": {
            "total_utilisateurs": 2,
            "utilisateurs_actifs": 1,
            "taux_activation": 0.5
        }
    }

    # √âcriture JSON standard
    print("   1Ô∏è‚É£ JSON standard (compact) :")
    with open("output_files/donnees_compact.json", "w", encoding="utf-8") as f:
        json.dump(donnees, f, ensure_ascii=False)
    print("      ‚úÖ JSON compact g√©n√©r√©")

    # √âcriture JSON format√©
    print("   2Ô∏è‚É£ JSON format√© (lisible) :")
    with open("output_files/donnees_lisible.json", "w", encoding="utf-8") as f:
        json.dump(donnees, f, ensure_ascii=False, indent=2, sort_keys=True)
    print("      ‚úÖ JSON format√© g√©n√©r√©")

    # JSON avec types personnalis√©s
    print("   3Ô∏è‚É£ JSON avec s√©rialiseur personnalis√© :")

    class EncodeurPersonnalise(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            elif isinstance(obj, date):
                return obj.isoformat()
            return super().default(obj)

    donnees_avec_dates = {
        "timestamp": datetime.now(),
        "date_creation": date.today(),
        "donnees": donnees
    }

    with open("output_files/donnees_avec_dates.json", "w", encoding="utf-8") as f:
        json.dump(donnees_avec_dates, f, cls=EncodeurPersonnalise,
                  ensure_ascii=False, indent=2)
    print("      ‚úÖ JSON avec dates g√©n√©r√©")

    # V√©rification des tailles
    tailles = {}
    for nom in ["compact", "lisible", "avec_dates"]:
        fichier = f"output_files/donnees_{nom}.json"
        taille = os.path.getsize(fichier)
        tailles[nom] = taille
        print(f"      {nom:<12} : {taille:,} octets")


generer_json()

print("\nüìã G√âN√âRATION DE MARKDOWN")
print("-" * 26)


def generer_markdown():
    """G√©n√©ration de fichiers Markdown"""

    print("üìã G√©n√©ration de fichiers Markdown :")

    # Donn√©es pour le rapport
    donnees_rapport = {
        "titre": "Rapport d'Activit√© Mensuel",
        "date": "Janvier 2024",
        "auteur": "Jean Dupont",
        "sections": [
            {
                "titre": "R√©sum√© Ex√©cutif",
                "contenu": "Ce mois a √©t√© marqu√© par une croissance significative de nos activit√©s."
            },
            {
                "titre": "M√©triques Cl√©s",
                "contenu": "Voici les principales m√©triques du mois :"
            }
        ],
        "metriques": [
            {"nom": "Utilisateurs actifs", "valeur": 15420, "evolution": "+12%"},
            {"nom": "Revenus", "valeur": 85300, "evolution": "+8%"},
            {"nom": "Taux de satisfaction", "valeur": 94.5, "evolution": "+2%"}
        ],
        "taches": [
            {"nom": "Am√©liorer la performance", "statut": "‚úÖ Termin√©"},
            {"nom": "Nouvelle fonctionnalit√©", "statut": "üöß En cours"},
            {"nom": "Documentation", "statut": "üìã Planifi√©"}
        ]
    }

    with open("output_files/rapport.md", "w", encoding="utf-8") as f:
        # En-t√™te
        f.write(f"# {donnees_rapport['titre']}\n\n")
        f.write(f"**Date :** {donnees_rapport['date']}  \n")
        f.write(f"**Auteur :** {donnees_rapport['auteur']}  \n\n")
        f.write("---\n\n")

        # Table des mati√®res
        f.write("## Table des Mati√®res\n\n")
        for i, section in enumerate(donnees_rapport['sections'], 1):
            f.write(
                f"{i}. [{section['titre']}](#{section['titre'].lower().replace(' ', '-')})\n")
        f.write("3. [M√©triques](#m√©triques)\n")
        f.write("4. [T√¢ches](#t√¢ches)\n\n")

        # Sections
        for section in donnees_rapport['sections']:
            f.write(f"## {section['titre']}\n\n")
            f.write(f"{section['contenu']}\n\n")

        # M√©triques sous forme de tableau
        f.write("## M√©triques\n\n")
        f.write("| M√©trique | Valeur | √âvolution |\n")
        f.write("|----------|--------|----------|\n")
        for metrique in donnees_rapport['metriques']:
            valeur = f"{metrique['valeur']:,}" if isinstance(
                metrique['valeur'], int) else metrique['valeur']
            f.write(
                f"| {metrique['nom']} | {valeur} | {metrique['evolution']} |\n")
        f.write("\n")

        # T√¢ches sous forme de liste
        f.write("## T√¢ches\n\n")
        for tache in donnees_rapport['taches']:
            f.write(f"- **{tache['nom']}** : {tache['statut']}\n")
        f.write("\n")

        # Code exemple
        f.write("## Exemple de Code\n\n")
        f.write("```python\n")
        f.write("def calculer_croissance(ancien, nouveau):\n")
        f.write("    return ((nouveau - ancien) / ancien) * 100\n")
        f.write("\n")
        f.write("croissance = calculer_croissance(1000, 1120)\n")
        f.write("print(f'Croissance: {croissance:.1f}%')\n")
        f.write("```\n\n")

        # Conclusion
        f.write("## Conclusion\n\n")
        f.write("> Les r√©sultats de ce mois montrent une **progression constante** ")
        f.write("de nos indicateurs cl√©s. Nous restons confiants pour la suite.\n\n")
        f.write("---\n\n")
        f.write("*Rapport g√©n√©r√© automatiquement*\n")

    print("   ‚úÖ Rapport Markdown g√©n√©r√©")

    # V√©rification
    with open("output_files/rapport.md", "r", encoding="utf-8") as f:
        lignes = f.readlines()
        print(f"   üìä Fichier g√©n√©r√© : {len(lignes)} lignes")


generer_markdown()

print("\n" + "=" * 50)
print("7. EXERCICES PRATIQUES")
print("=" * 50)

print("""
üí™ EXERCICES √Ä IMPL√âMENTER :

üéØ Exercice 1 : G√©n√©rateur de rapports
Cr√©ez un syst√®me de g√©n√©ration de rapports :
‚Ä¢ Support multiple formats (HTML, PDF, CSV, JSON)
‚Ä¢ Templates configurables
‚Ä¢ Graphiques int√©gr√©s (matplotlib)
‚Ä¢ Export automatique par email
‚Ä¢ Planification et archivage

üìä Exercice 2 : Logger personnalis√©
Cr√©ez votre propre syst√®me de logging :
‚Ä¢ Rotation automatique des fichiers
‚Ä¢ Niveaux de log configurables
‚Ä¢ Format personnalisable avec couleurs
‚Ä¢ Compression des anciens logs
‚Ä¢ Dashboard de monitoring

üîÑ Exercice 3 : Syst√®me de sauvegarde
Cr√©ez un syst√®me de sauvegarde incr√©mentale :
‚Ä¢ D√©tection des changements
‚Ä¢ Compression et d√©duplication
‚Ä¢ Sauvegarde vers cloud (S3, etc.)
‚Ä¢ Restauration s√©lective
‚Ä¢ V√©rification d'int√©grit√©

üìù Exercice 4 : √âditeur de configuration
Cr√©ez un √©diteur pour fichiers de config :
‚Ä¢ Support YAML, JSON, INI, TOML
‚Ä¢ Validation en temps r√©el
‚Ä¢ Interface web ou GUI
‚Ä¢ Historique des changements
‚Ä¢ D√©ploiement automatique

üéÆ Exercice 5 : G√©n√©rateur de code
Cr√©ez un g√©n√©rateur de code source :
‚Ä¢ Templates Jinja2 ou similaire
‚Ä¢ M√©tadonn√©es depuis JSON/YAML
‚Ä¢ Support multi-langages
‚Ä¢ Tests automatiques g√©n√©r√©s
‚Ä¢ Documentation int√©gr√©e
""")

print("\n" + "=" * 50)
print("8. R√âSUM√â FINAL")
print("=" * 50)

print("""
üéØ POINTS CL√âS √Ä RETENIR :

1. üìù M√âTHODES D'√âCRITURE :
   ‚Ä¢ write(string) : √©crire une cha√Æne
   ‚Ä¢ writelines(list) : √©crire une liste (sans \\n automatique !)
   ‚Ä¢ print(file=f) : utiliser print() vers fichier
   ‚Ä¢ Toujours utiliser encoding='utf-8'

2. üé≠ MODES D'√âCRITURE :
   ‚Ä¢ 'w' : √©crasement complet du fichier
   ‚Ä¢ 'a' : ajout en fin de fichier
   ‚Ä¢ 'x' : cr√©ation exclusive (√©choue si existe)
   ‚Ä¢ '+' : combinaison lecture/√©criture
   ‚Ä¢ 'b' : mode binaire vs 't' mode texte

3. ‚ö° PERFORMANCE ET BUFFERING :
   ‚Ä¢ Buffering automatique pour performance
   ‚Ä¢ flush() pour forcer l'√©criture sur disque
   ‚Ä¢ writelines() plus rapide que write() en boucle
   ‚Ä¢ √âviter flush() apr√®s chaque write() (tr√®s lent)

4. üõ°Ô∏è S√âCURIT√â :
   ‚Ä¢ Context managers (with) obligatoires
   ‚Ä¢ √âcriture atomique pour donn√©es critiques
   ‚Ä¢ Gestion des permissions de fichiers
   ‚Ä¢ Verrouillage pour acc√®s concurrent
   ‚Ä¢ Validation avant √©criture

5. üìä FORMATS SP√âCIALIS√âS :
   ‚Ä¢ CSV : module csv pour √©chappement correct
   ‚Ä¢ JSON : json.dump() avec encodage proper
   ‚Ä¢ Markdown : g√©n√©ration programmatique
   ‚Ä¢ Binaires : struct pour donn√©es structur√©es

üí° BONNES PRATIQUES :
‚úÖ Toujours utiliser with pour ouvrir des fichiers
‚úÖ Sp√©cifier encoding='utf-8' explicitement
‚úÖ flush() seulement quand n√©cessaire (donn√©es critiques)
‚úÖ √âcriture atomique pour √©viter corruption
‚úÖ Valider les donn√©es avant √©criture
‚úÖ G√©rer les erreurs d'espace disque et permissions

üö® ERREURS COURANTES :
‚ùå Oublier le \\n dans writelines()
‚ùå Mode 'w' efface tout le contenu existant
‚ùå Pas de gestion d'erreurs (disque plein, permissions)
‚ùå flush() apr√®s chaque write() (performance)
‚ùå Oublier de fermer les fichiers
‚ùå Encodage incorrect pour caract√®res sp√©ciaux

‚ö° OPTIMISATIONS :
‚Ä¢ Utiliser writelines() pour √©criture en lot
‚Ä¢ Buffer les donn√©es avant √©criture massive
‚Ä¢ √âcriture par blocs pour gros volumes
‚Ä¢ Compression pour √©conomiser l'espace
‚Ä¢ Threads pour E/S parall√®les

üîß PATTERNS AVANC√âS :
‚Ä¢ Context managers personnalis√©s
‚Ä¢ Factories de writers par format
‚Ä¢ Pipelines de transformation de donn√©es
‚Ä¢ Syst√®me de templates
‚Ä¢ G√©n√©ration de code automatique

üéØ CAS D'USAGE COURANTS :
‚Ä¢ Logs d'application avec rotation
‚Ä¢ Export de donn√©es en CSV/JSON
‚Ä¢ G√©n√©ration de rapports
‚Ä¢ Sauvegarde de configuration
‚Ä¢ Cache de donn√©es sur disque

üîç DEBUGGING :
‚Ä¢ V√©rifier les permissions de fichier
‚Ä¢ Contr√¥ler l'espace disque disponible
‚Ä¢ Tester avec des caract√®res sp√©ciaux
‚Ä¢ Simuler les erreurs d'E/O
‚Ä¢ Surveiller les performances

üéâ F√©licitations ! √âcriture de fichiers ma√Ætris√©e !
üí° Prochaine √©tape : Context managers !
üìö √âcriture ma√Ætris√©e, explorez les context managers !
""")

print("\n" + "=" * 70)
print("üéØ FIN DU GUIDE - √âCRITURE DE FICHIERS MA√éTRIS√âE !")
print("=" * 70)
