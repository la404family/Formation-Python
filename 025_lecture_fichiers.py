#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
======================================================================
LECTURE DE FICHIERS EN PYTHON - GUIDE COMPLET
======================================================================

üéØ Ce fichier couvre la lecture de fichiers en d√©tail :
   ‚Ä¢ Ouverture et fermeture de fichiers
   ‚Ä¢ Modes d'ouverture et encodage
   ‚Ä¢ M√©thodes de lecture (read, readline, readlines)
   ‚Ä¢ Context managers (with)
   ‚Ä¢ Gestion d'erreurs pour fichiers
   ‚Ä¢ Fichiers binaires vs texte

üìö Concepts abord√©s :
   ‚Ä¢ File objects et m√©thodes
   ‚Ä¢ Buffering et performance
   ‚Ä¢ Encodage de caract√®res
   ‚Ä¢ Chemins et pathlib
   ‚Ä¢ Parsing de formats courants
   ‚Ä¢ S√©curit√© et validation

üí° Objectif : Ma√Ætriser la lecture efficace de fichiers
"""

import os
print("=" * 70)
print("LECTURE DE FICHIERS EN PYTHON - GUIDE COMPLET")
print("=" * 70)

print("\n" + "=" * 50)
print("1. FONDAMENTAUX DE LA LECTURE")
print("=" * 50)

print("\nüìÇ QU'EST-CE QU'UN FICHIER ?")
print("-" * 28)

print("""
üéØ D√âFINITION :
Un fichier est une s√©quence d'octets stock√©e sur un syst√®me de stockage,
identifi√©e par un nom et organis√©e par le syst√®me de fichiers.

üîÑ TYPES DE FICHIERS :
‚Ä¢ Fichiers texte : contenu interpr√©t√© comme caract√®res
‚Ä¢ Fichiers binaires : s√©quence brute d'octets
‚Ä¢ Fichiers sp√©ciaux : p√©riph√©riques, pipes, etc.

üìä M√âTADONN√âES :
‚Ä¢ Nom et extension
‚Ä¢ Taille en octets
‚Ä¢ Dates (cr√©ation, modification, acc√®s)
‚Ä¢ Permissions (lecture, √©criture, ex√©cution)
‚Ä¢ Propri√©taire et groupe

‚ö° OP√âRATIONS DE BASE :
‚Ä¢ Ouverture (open) : cr√©er un objet fichier
‚Ä¢ Lecture (read) : r√©cup√©rer le contenu
‚Ä¢ Position (seek/tell) : naviguer dans le fichier
‚Ä¢ Fermeture (close) : lib√©rer les ressources
""")

print("\nüîß FONCTION OPEN() - SYNTAXE")
print("-" * 29)

print("""
üéØ SYNTAXE COMPL√àTE :
open(file, mode='r', buffering=-1, encoding=None, 
     errors=None, newline=None, closefd=True, opener=None)

üìã PARAM√àTRES PRINCIPAUX :
‚Ä¢ file : chemin du fichier (str ou Path)
‚Ä¢ mode : mode d'ouverture ('r', 'w', 'a', 'x', etc.)
‚Ä¢ encoding : encodage des caract√®res ('utf-8', 'cp1252', etc.)
‚Ä¢ buffering : taille du buffer (-1=syst√®me, 0=non bufferis√©)
‚Ä¢ errors : gestion des erreurs d'encodage
‚Ä¢ newline : gestion des fins de ligne

üö® IMPORTANT :
Toujours fermer les fichiers apr√®s usage !
Utiliser des context managers (with) pour la s√©curit√©.
""")

# Cr√©ons d'abord quelques fichiers de test

# Cr√©er le r√©pertoire test_files s'il n'existe pas
os.makedirs("test_files", exist_ok=True)

# Cr√©er un fichier texte simple
with open("test_files/exemple_simple.txt", "w", encoding="utf-8") as f:
    f.write("""Bonjour le monde !
Ceci est un fichier de test.
Il contient plusieurs lignes.
Chaque ligne se termine par un retour √† la ligne.
Ligne 5 avec des caract√®res sp√©ciaux : √©√†√π√ß
""")

# Cr√©er un fichier CSV
with open("test_files/donnees.csv", "w", encoding="utf-8") as f:
    f.write("""nom,age,ville
Alice,25,Paris
Bob,30,Lyon
Charlie,35,Marseille
Diane,28,Toulouse
Eve,22,Nice
""")

# Cr√©er un fichier JSON
with open("test_files/configuration.json", "w", encoding="utf-8") as f:
    f.write("""{
    "version": "1.0",
    "debug": true,
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "app_db"
    },
    "features": ["auth", "logging", "cache"],
    "limits": {
        "max_users": 1000,
        "timeout": 30.5
    }
}""")

# Cr√©er un fichier de log
with open("test_files/application.log", "w", encoding="utf-8") as f:
    f.write("""2024-01-15 10:00:00 INFO Application d√©marr√©e
2024-01-15 10:00:01 DEBUG Configuration charg√©e
2024-01-15 10:00:02 INFO Connexion base de donn√©es OK
2024-01-15 10:05:30 WARNING Cache presque plein (85%)
2024-01-15 10:10:15 ERROR Timeout connexion utilisateur 123
2024-01-15 10:10:16 INFO Reconnexion automatique r√©ussie
2024-01-15 10:15:00 INFO 50 utilisateurs actifs
""")

print("üìÅ Fichiers de test cr√©√©s dans le r√©pertoire 'test_files/'")

print("\n" + "=" * 50)
print("2. MODES D'OUVERTURE")
print("=" * 50)

print("\nüé≠ MODES DE BASE")
print("-" * 16)

modes_base = [
    ("'r'", "Lecture seule (d√©faut)", "Fichier doit exister"),
    ("'w'", "√âcriture seule", "Cr√©e/√©crase le fichier"),
    ("'a'", "Ajout en fin", "Cr√©e le fichier si n√©cessaire"),
    ("'x'", "Cr√©ation exclusive", "√âchoue si fichier existe"),
    ("'r+'", "Lecture/√©criture", "Fichier doit exister"),
    ("'w+'", "Lecture/√©criture", "Cr√©e/√©crase le fichier"),
    ("'a+'", "Lecture/ajout", "Cr√©e le fichier si n√©cessaire"),
]

print("üé≠ Modes d'ouverture principaux :")
for mode, description, comportement in modes_base:
    print(f"   {mode:<6} : {description:<20} | {comportement}")

print("\nüî§ MODIFICATEURS DE MODE")
print("-" * 24)

print("""
üî§ MODIFICATEURS :
‚Ä¢ 'b' : Mode binaire (ex: 'rb', 'wb')
‚Ä¢ 't' : Mode texte (d√©faut, ex: 'rt', 'wt')

üìù EXEMPLES :
‚Ä¢ 'r'   = 'rt'  : lecture texte
‚Ä¢ 'rb'          : lecture binaire
‚Ä¢ 'w'   = 'wt'  : √©criture texte
‚Ä¢ 'wb'          : √©criture binaire
‚Ä¢ 'a+'  = 'a+t' : ajout + lecture texte
‚Ä¢ 'r+b'         : lecture/√©criture binaire
""")

print("\nüß™ TESTS DES MODES D'OUVERTURE")
print("-" * 30)


def tester_mode_ouverture(fichier, mode, description):
    """Test d'ouverture avec un mode sp√©cifique"""
    try:
        with open(fichier, mode, encoding="utf-8" if 'b' not in mode else None) as f:
            print(f"   ‚úÖ {mode:<4} ({description}) : Ouverture r√©ussie")

            # Informations sur le fichier
            print(f"      Mode : {f.mode}")
            print(f"      Nom : {f.name}")
            print(f"      Lisible : {f.readable()}")
            print(f"      √âcrivable : {f.writable()}")

            # Essayer de lire quelques caract√®res si possible
            if f.readable():
                position_initiale = f.tell()
                try:
                    if 'b' in mode:
                        preview = f.read(20)
                        print(f"      Aper√ßu : {preview}")
                    else:
                        preview = f.read(30)
                        print(f"      Aper√ßu : '{preview.replace(chr(10), '\\n')}'")
                except:
                    print(f"      Aper√ßu : Non disponible")

                # Remettre au d√©but si on a lu
                f.seek(position_initiale)

    except Exception as e:
        print(f"   ‚ùå {mode:<4} ({description}) : {e}")


print("üß™ Tests des modes sur fichier existant :")
fichier_test = "test_files/exemple_simple.txt"

modes_test = [
    ('r', 'Lecture seule'),
    ('r+', 'Lecture/√©criture'),
    ('rb', 'Lecture binaire'),
    ('rt', 'Lecture texte explicite'),
]

for mode, desc in modes_test:
    tester_mode_ouverture(fichier_test, mode, desc)
    print()

print("\n" + "=" * 50)
print("3. M√âTHODES DE LECTURE")
print("=" * 50)

print("\nüìñ READ() - LECTURE COMPL√àTE")
print("-" * 28)


def demo_read_complete():
    """D√©monstration de read() pour lecture compl√®te"""

    print("üìñ Lecture compl√®te du fichier :")
    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            contenu_complet = f.read()
            print(f"   Type : {type(contenu_complet)}")
            print(f"   Longueur : {len(contenu_complet)} caract√®res")
            print(
                f"   Nombre de lignes : {contenu_complet.count(chr(10)) + 1}")
            print("   Contenu :")
            for i, ligne in enumerate(contenu_complet.split('\n'), 1):
                print(f"      {i:2d}: {ligne}")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_read_complete()

print("\nüìÑ READ(SIZE) - LECTURE PARTIELLE")
print("-" * 32)


def demo_read_partielle():
    """D√©monstration de read(size) pour lecture par blocs"""

    print("üìÑ Lecture par blocs de 20 caract√®res :")
    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            bloc_num = 1
            while True:
                bloc = f.read(20)  # Lire 20 caract√®res
                if not bloc:  # Fin de fichier
                    break

                print(f"   Bloc {bloc_num} ({len(bloc)} chars) : '{bloc.replace(chr(10), '\\n')}'")
                bloc_num += 1

                if bloc_num > 10:  # Limiter pour la d√©mo
                    print("   ... (lecture limit√©e pour la d√©mo)")
                    break

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_read_partielle()

print("\nüìù READLINE() - LECTURE LIGNE PAR LIGNE")
print("-" * 37)


def demo_readline():
    """D√©monstration de readline() pour lecture s√©quentielle"""

    print("üìù Lecture ligne par ligne avec readline() :")
    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            ligne_num = 1
            while True:
                ligne = f.readline()
                if not ligne:  # Fin de fichier
                    break

                # Afficher avec informations
                # Enlever les retours √† la ligne
                ligne_propre = ligne.rstrip('\n\r')
                print(
                    f"   Ligne {ligne_num} ({len(ligne)} chars) : '{ligne_propre}'")
                ligne_num += 1

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_readline()

print("\nüìã READLINES() - TOUTES LES LIGNES")
print("-" * 33)


def demo_readlines():
    """D√©monstration de readlines() pour charger toutes les lignes"""

    print("üìã Lecture de toutes les lignes avec readlines() :")
    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            toutes_lignes = f.readlines()

            print(f"   Type : {type(toutes_lignes)}")
            print(f"   Nombre de lignes : {len(toutes_lignes)}")

            for i, ligne in enumerate(toutes_lignes, 1):
                ligne_propre = ligne.rstrip('\n\r')
                print(f"   [{i}] : '{ligne_propre}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_readlines()

print("\nüîÑ IT√âRATION SUR FICHIER")
print("-" * 24)


def demo_iteration_fichier():
    """D√©monstration de l'it√©ration directe sur un fichier"""

    print("üîÑ It√©ration directe sur le fichier (m√©thode recommand√©e) :")
    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            for numero_ligne, ligne in enumerate(f, 1):
                ligne_propre = ligne.rstrip('\n\r')
                print(f"   Ligne {numero_ligne} : '{ligne_propre}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_iteration_fichier()

print("\n‚ö° COMPARAISON DES PERFORMANCES")
print("-" * 32)


def comparer_methodes_lecture():
    """Comparaison des performances des diff√©rentes m√©thodes"""
    import time

    # Cr√©er un fichier plus grand pour le test
    with open("test_files/gros_fichier.txt", "w", encoding="utf-8") as f:
        for i in range(1000):
            f.write(
                f"Ligne {i:04d} avec du contenu pour tester les performances de lecture\n")

    methodes = [
        ("read()", lambda f: f.read()),
        ("readlines()", lambda f: f.readlines()),
        ("iteration", lambda f: list(f)),
        ("readline loop", lambda f: [f.readline()
         for _ in range(1000) if f.readline()]),
    ]

    print("‚ö° Test de performance sur 1000 lignes :")

    # √âviter la m√©thode readline loop qui est bug√©e
    for nom, methode in methodes[:3]:
        try:
            start_time = time.time()

            with open("test_files/gros_fichier.txt", "r", encoding="utf-8") as f:
                resultat = methode(f)

            end_time = time.time()
            duree = (end_time - start_time) * 1000  # en ms

            if isinstance(resultat, str):
                nb_lignes = resultat.count('\n')
            else:
                nb_lignes = len(resultat)

            print(f"   {nom:<15} : {duree:6.2f} ms ({nb_lignes} lignes)")

        except Exception as e:
            print(f"   {nom:<15} : ‚ùå Erreur - {e}")


comparer_methodes_lecture()

print("\n" + "=" * 50)
print("4. GESTION DE LA POSITION")
print("=" * 50)

print("\nüìç TELL() ET SEEK() - NAVIGATION")
print("-" * 32)


def demo_position_fichier():
    """D√©monstration de la gestion de position dans un fichier"""

    print("üìç Navigation dans un fichier avec tell() et seek() :")

    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            # Position initiale
            print(f"   Position initiale : {f.tell()}")

            # Lire quelques caract√®res
            debut = f.read(10)
            print(f"   Apr√®s lecture de 10 chars : position {f.tell()}")
            print(f"   Texte lu : '{debut}'")

            # Revenir au d√©but
            f.seek(0)
            print(f"   Apr√®s seek(0) : position {f.tell()}")

            # Aller √† la position 20
            f.seek(20)
            print(f"   Apr√®s seek(20) : position {f.tell()}")
            suite = f.read(15)
            print(f"   Texte √† partir de la position 20 : '{suite}'")

            # Aller √† la fin
            f.seek(0, 2)  # 2 = SEEK_END
            taille_fichier = f.tell()
            print(f"   Taille du fichier : {taille_fichier} octets")

            # Position relative
            f.seek(0)  # Retour au d√©but
            f.read(5)  # Lire 5 caract√®res
            print(f"   Position avant seek relatif : {f.tell()}")
            f.seek(10, 1)  # 1 = SEEK_CUR (position courante + 10)
            print(f"   Position apr√®s seek(+10) relatif : {f.tell()}")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_position_fichier()

print("\nüéØ MODES DE SEEK")
print("-" * 16)

print("""
üéØ CONSTANTES DE SEEK :
‚Ä¢ 0 ou os.SEEK_SET : depuis le d√©but du fichier
‚Ä¢ 1 ou os.SEEK_CUR : depuis la position courante
‚Ä¢ 2 ou os.SEEK_END : depuis la fin du fichier

üìê EXEMPLES :
‚Ä¢ seek(0)     : aller au d√©but
‚Ä¢ seek(0, 2)  : aller √† la fin
‚Ä¢ seek(-10, 2): 10 octets avant la fin
‚Ä¢ seek(5, 1)  : avancer de 5 octets
‚Ä¢ seek(-3, 1) : reculer de 3 octets

‚ö†Ô∏è ATTENTION :
En mode texte, seek() avec offset relatif peut poser probl√®me
avec l'encodage multi-octets. Pr√©f√©rer les positions absolues.
""")


def demo_seek_avance():
    """D√©monstration avanc√©e de seek()"""

    print("üéØ Techniques avanc√©es de navigation :")

    try:
        with open("test_files/donnees.csv", "r", encoding="utf-8") as f:
            # M√©moriser des positions importantes
            positions = {}

            # Lire l'en-t√™te
            positions['debut'] = f.tell()
            header = f.readline()
            positions['apres_header'] = f.tell()
            print(f"   En-t√™te : '{header.strip()}'")

            # Lire quelques lignes en m√©morisant les positions
            for i in range(3):
                pos_avant = f.tell()
                ligne = f.readline()
                if ligne:
                    positions[f'ligne_{i+1}'] = pos_avant
                    print(
                        f"   Ligne {i+1} (pos {pos_avant}) : '{ligne.strip()}'")

            print(f"\n   Positions m√©moris√©es : {positions}")

            # Revenir √† une position sp√©cifique
            print(f"\n   Retour √† la ligne 2 :")
            f.seek(positions['ligne_2'])
            ligne_2_bis = f.readline()
            print(f"   Relecture : '{ligne_2_bis.strip()}'")

            # Lire les derniers caract√®res
            f.seek(-20, 2)  # 20 caract√®res avant la fin
            fin = f.read()
            print(f"   Fin du fichier : '{fin.replace(chr(10), '\\n')}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_seek_avance()

print("\n" + "=" * 50)
print("5. ENCODAGE ET CARACT√àRES")
print("=" * 50)

print("\nüåç ENCODAGES DE CARACT√àRES")
print("-" * 26)

print("""
üåç ENCODAGES COURANTS :
‚Ä¢ UTF-8 : Standard universel, compatible ASCII
‚Ä¢ UTF-16 : Unicode 16 bits, BOM optionnel
‚Ä¢ UTF-32 : Unicode 32 bits, fixe
‚Ä¢ CP1252 : Windows Western Europe (Latin-1 √©tendu)
‚Ä¢ ISO-8859-1 : Latin-1, Europe occidentale
‚Ä¢ ASCII : 7 bits, caract√®res de base seulement

üéØ RECOMMANDATION :
Toujours sp√©cifier encoding='utf-8' pour la compatibilit√© !
""")


def demo_encodages():
    """D√©monstration des diff√©rents encodages"""

    # Cr√©er des fichiers avec diff√©rents encodages
    texte_multilingue = "Bonjour ! H√©llo! ‰Ω†Â•Ω! –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π! ŸÖÿ±ÿ≠ÿ®ÿß"

    encodages_test = [
        ('utf-8', 'UTF-8 standard'),
        ('utf-16', 'UTF-16 avec BOM'),
        ('cp1252', 'Windows-1252'),
        ('iso-8859-1', 'Latin-1'),
    ]

    print("üåç Test des encodages :")

    for encodage, description in encodages_test:
        try:
            # √âcrire avec l'encodage
            nom_fichier = f"test_files/test_{encodage.replace('-', '_')}.txt"
            with open(nom_fichier, "w", encoding=encodage) as f:
                f.write(texte_multilingue)

            # Lire avec le m√™me encodage
            with open(nom_fichier, "r", encoding=encodage) as f:
                contenu = f.read()

            print(f"   ‚úÖ {encodage:<12} ({description}) : '{contenu}'")

            # Taille du fichier
            taille = os.path.getsize(nom_fichier)
            print(f"      Taille : {taille} octets")

        except Exception as e:
            print(f"   ‚ùå {encodage:<12} : {e}")

    print()


demo_encodages()

print("\n‚ö†Ô∏è ERREURS D'ENCODAGE")
print("-" * 22)


def demo_erreurs_encodage():
    """D√©monstration des erreurs d'encodage"""

    print("‚ö†Ô∏è Gestion des erreurs d'encodage :")

    # Cr√©er un fichier avec caract√®res sp√©ciaux
    texte_special = "Caf√© fran√ßais : 15‚Ç¨ ‚Äî Tr√®s bon !"

    with open("test_files/test_utf8.txt", "w", encoding="utf-8") as f:
        f.write(texte_special)

    # Essayer de lire avec diff√©rents encodages
    strat√©gies_erreur = [
        ('strict', 'Lever une exception (d√©faut)'),
        ('ignore', 'Ignorer les caract√®res probl√©matiques'),
        ('replace', 'Remplacer par des marqueurs'),
        ('xmlcharrefreplace', 'Remplacer par des r√©f√©rences XML'),
        ('backslashreplace', 'Remplacer par des s√©quences \\u'),
    ]

    for strategie, description in strat√©gies_erreur:
        try:
            with open("test_files/test_utf8.txt", "r", encoding="ascii", errors=strategie) as f:
                contenu = f.read()
            print(f"   {strategie:<18} : '{contenu}'")
            print(f"      {description}")

        except Exception as e:
            print(f"   {strategie:<18} : ‚ùå {e}")

        print()


demo_erreurs_encodage()

print("\nüîç D√âTECTION D'ENCODAGE")
print("-" * 23)


def analyser_encodage_fichier(nom_fichier):
    """Analyse l'encodage probable d'un fichier"""

    print(f"üîç Analyse de l'encodage de '{nom_fichier}' :")

    try:
        # Lire en mode binaire pour analyser
        with open(nom_fichier, "rb") as f:
            debut = f.read(100)  # Premiers 100 octets

        print(f"   Premiers octets : {debut[:20]}")

        # Tester diff√©rents encodages
        encodages_test = ['utf-8', 'utf-16', 'cp1252', 'iso-8859-1']

        for encodage in encodages_test:
            try:
                with open(nom_fichier, "r", encoding=encodage) as f:
                    contenu = f.read(50)  # Lire quelques caract√®res
                print(f"   ‚úÖ {encodage:<12} : '{contenu.replace(chr(10), '\\n')[:30]}...'")

            except UnicodeDecodeError as e:
                print(f"   ‚ùå {encodage:<12} : Erreur de d√©codage")
            except Exception as e:
                print(f"   ‚ùå {encodage:<12} : {e}")

    except Exception as e:
        print(f"   ‚ùå Erreur d'analyse : {e}")

    print()


# Analyser nos fichiers de test
analyser_encodage_fichier("test_files/test_utf_8.txt")
analyser_encodage_fichier("test_files/test_utf_16.txt")

print("\n" + "=" * 50)
print("6. CONTEXT MANAGERS (WITH)")
print("=" * 50)

print("\nüîí POURQUOI UTILISER WITH ?")
print("-" * 27)

print("""
üîí PROBL√àMES SANS CONTEXT MANAGER :
‚Ä¢ Oubli de fermer les fichiers (fuite de ressources)
‚Ä¢ Fichiers restent ouverts en cas d'exception
‚Ä¢ Gestion manuelle des erreurs complexe
‚Ä¢ Code verbeux et r√©p√©titif

‚úÖ AVANTAGES AVEC WITH :
‚Ä¢ Fermeture automatique garantie
‚Ä¢ M√™me en cas d'exception
‚Ä¢ Code plus lisible et s√ªr
‚Ä¢ Gestion des ressources simplifi√©e
‚Ä¢ Pattern recommand√© par Python
""")

print("\n‚ùå MAUVAISE PRATIQUE")
print("-" * 20)


def demo_sans_with():
    """D√©monstration des probl√®mes sans context manager"""

    print("‚ùå Ouverture sans context manager (MAUVAIS) :")

    try:
        # Mauvaise pratique
        f = open("test_files/exemple_simple.txt", "r", encoding="utf-8")
        contenu = f.read()
        print(f"   Contenu lu : {len(contenu)} caract√®res")

        # Si une exception se produit ici, le fichier reste ouvert !
        # Par exemple : division par z√©ro
        # resultat = 10 / 0  # D√©commentez pour voir le probl√®me

        f.close()  # Cette ligne pourrait ne jamais √™tre ex√©cut√©e !
        print("   Fichier ferm√© manuellement")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        # Le fichier reste ouvert !
        try:
            f.close()
            print("   Fichier ferm√© dans except")
        except:
            print("   Impossible de fermer le fichier")


demo_sans_with()

print("\n‚úÖ BONNE PRATIQUE")
print("-" * 18)


def demo_avec_with():
    """D√©monstration avec context manager"""

    print("‚úÖ Ouverture avec context manager (BON) :")

    try:
        with open("test_files/exemple_simple.txt", "r", encoding="utf-8") as f:
            contenu = f.read()
            print(f"   Contenu lu : {len(contenu)} caract√®res")
            print(f"   Fichier ouvert : {not f.closed}")

            # M√™me si une exception se produit ici...
            # resultat = 10 / 0  # Le fichier sera ferm√© automatiquement !

        print(f"   Fichier ferm√© automatiquement : {f.closed}")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        print(f"   Fichier ferm√© malgr√© l'erreur : {f.closed}")


demo_avec_with()

print("\nüîÑ MULTIPLES FICHIERS")
print("-" * 21)


def demo_multiples_fichiers():
    """Ouverture de multiples fichiers avec with"""

    print("üîÑ Ouverture de multiples fichiers :")

    try:
        # M√©thode 1 : with imbriqu√©s
        print("   M√©thode 1 - with imbriqu√©s :")
        with open("test_files/donnees.csv", "r", encoding="utf-8") as f1:
            with open("test_files/application.log", "r", encoding="utf-8") as f2:
                lignes_csv = len(f1.readlines())
                lignes_log = len(f2.readlines())
                print(f"      CSV : {lignes_csv} lignes")
                print(f"      LOG : {lignes_log} lignes")

        # M√©thode 2 : with multiple (Python 2.7+)
        print("   M√©thode 2 - with multiple :")
        with open("test_files/donnees.csv", "r", encoding="utf-8") as f1, \
                open("test_files/application.log", "r", encoding="utf-8") as f2:

            premiere_ligne_csv = f1.readline().strip()
            premiere_ligne_log = f2.readline().strip()
            print(f"      Premi√®re ligne CSV : '{premiere_ligne_csv}'")
            print(f"      Premi√®re ligne LOG : '{premiere_ligne_log}'")

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")


demo_multiples_fichiers()

print("\nüõ†Ô∏è CONTEXT MANAGER PERSONNALIS√â")
print("-" * 32)


class GestionnaireFichierAvecLog:
    """Context manager personnalis√© avec logging"""

    def __init__(self, nom_fichier, mode="r", encoding="utf-8", log=True):
        self.nom_fichier = nom_fichier
        self.mode = mode
        self.encoding = encoding
        self.log = log
        self.fichier = None
        self.temps_ouverture = None

    def __enter__(self):
        """Entr√©e dans le context manager"""
        if self.log:
            import time
            self.temps_ouverture = time.time()
            print(
                f"   üìÇ Ouverture de '{self.nom_fichier}' en mode '{self.mode}'")

        try:
            self.fichier = open(self.nom_fichier, self.mode,
                                encoding=self.encoding)
            if self.log:
                print(f"   ‚úÖ Fichier ouvert avec succ√®s")
            return self.fichier

        except Exception as e:
            if self.log:
                print(f"   ‚ùå Erreur d'ouverture : {e}")
            raise

    def __exit__(self, exc_type, exc_value, traceback):
        """Sortie du context manager"""
        if self.fichier:
            self.fichier.close()

            if self.log:
                import time
                duree = time.time() - self.temps_ouverture
                print(f"   üîí Fichier ferm√© (ouvert pendant {duree:.3f}s)")

                if exc_type:
                    print(
                        f"   ‚ö†Ô∏è Fermeture apr√®s exception : {exc_type.__name__}")
                else:
                    print(f"   ‚úÖ Fermeture normale")

        # Retourner False pour propager les exceptions
        return False


def demo_context_manager_personnalise():
    """Test du context manager personnalis√©"""

    print("üõ†Ô∏è Test du context manager personnalis√© :")

    # Test normal
    print("\n   Test normal :")
    with GestionnaireFichierAvecLog("test_files/exemple_simple.txt") as f:
        contenu = f.read(50)
        print(f"   üìñ Lu : '{contenu[:30]}...'")

    # Test avec exception
    print("\n   Test avec exception :")
    try:
        with GestionnaireFichierAvecLog("test_files/exemple_simple.txt") as f:
            contenu = f.read(10)
            # Simuler une erreur
            raise ValueError("Erreur simul√©e")
    except ValueError as e:
        print(f"   üö® Exception captur√©e : {e}")


demo_context_manager_personnalise()

print("\n" + "=" * 50)
print("7. PARSING DE FORMATS COURANTS")
print("=" * 50)

print("\nüìä FICHIERS CSV")
print("-" * 15)


def lire_csv_manuel():
    """Lecture manuelle d'un fichier CSV"""

    print("üìä Lecture manuelle de CSV :")

    try:
        with open("test_files/donnees.csv", "r", encoding="utf-8") as f:
            # Lire l'en-t√™te
            header = f.readline().strip().split(',')
            print(f"   En-t√™te : {header}")

            # Lire les donn√©es
            donnees = []
            # Commencer √† 2 (apr√®s header)
            for numero_ligne, ligne in enumerate(f, 2):
                if ligne.strip():  # Ignorer les lignes vides
                    valeurs = ligne.strip().split(',')
                    if len(valeurs) == len(header):
                        enregistrement = dict(zip(header, valeurs))
                        donnees.append(enregistrement)
                        print(f"   Ligne {numero_ligne} : {enregistrement}")
                    else:
                        print(
                            f"   ‚ö†Ô∏è Ligne {numero_ligne} mal form√©e : {valeurs}")

            print(f"   Total : {len(donnees)} enregistrements")
            return donnees

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        return []


donnees_csv = lire_csv_manuel()

print("\nüìä AVEC MODULE CSV")
print("-" * 19)


def lire_csv_module():
    """Lecture avec le module csv (recommand√©)"""
    import csv

    print("üìä Lecture avec module csv :")

    try:
        with open("test_files/donnees.csv", "r", encoding="utf-8", newline='') as f:
            lecteur = csv.DictReader(f)

            print(f"   Colonnes : {lecteur.fieldnames}")

            donnees = []
            for numero_ligne, enregistrement in enumerate(lecteur, 2):
                donnees.append(enregistrement)
                print(f"   Ligne {numero_ligne} : {enregistrement}")

            print(f"   Total : {len(donnees)} enregistrements")
            return donnees

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        return []


donnees_csv_module = lire_csv_module()

print("\nüîß JSON")
print("--------")


def lire_json():
    """Lecture d'un fichier JSON"""
    import json

    print("üîß Lecture de fichier JSON :")

    try:
        with open("test_files/configuration.json", "r", encoding="utf-8") as f:
            # Lecture compl√®te
            config = json.load(f)

            print(f"   Type : {type(config)}")
            print(f"   Cl√©s principales : {list(config.keys())}")

            # Affichage structur√©
            for cle, valeur in config.items():
                if isinstance(valeur, dict):
                    print(f"   {cle} : {dict} avec {len(valeur)} √©l√©ments")
                    for sous_cle, sous_valeur in valeur.items():
                        print(f"      {sous_cle} : {sous_valeur}")
                elif isinstance(valeur, list):
                    print(
                        f"   {cle} : {list} avec {len(valeur)} √©l√©ments : {valeur}")
                else:
                    print(f"   {cle} : {valeur}")

            return config

    except json.JSONDecodeError as e:
        print(f"   ‚ùå Erreur JSON : {e}")
        return None
    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        return None


config_json = lire_json()

print("\nüìù FICHIERS DE LOG")
print("-" * 18)


def analyser_logs():
    """Analyse d'un fichier de log"""
    import re
    from datetime import datetime

    print("üìù Analyse de fichier de log :")

    try:
        # Pattern pour parser les logs
        pattern_log = re.compile(
            r'(?P<date>\d{4}-\d{2}-\d{2})\s+'
            r'(?P<heure>\d{2}:\d{2}:\d{2})\s+'
            r'(?P<niveau>\w+)\s+'
            r'(?P<message>.*)'
        )

        statistiques = {'INFO': 0, 'DEBUG': 0, 'WARNING': 0, 'ERROR': 0}
        entrees_log = []

        with open("test_files/application.log", "r", encoding="utf-8") as f:
            for numero_ligne, ligne in enumerate(f, 1):
                ligne = ligne.strip()
                if ligne:
                    match = pattern_log.match(ligne)
                    if match:
                        donnees = match.groupdict()

                        # Parser la date/heure
                        timestamp_str = f"{donnees['date']} {donnees['heure']}"
                        timestamp = datetime.strptime(
                            timestamp_str, "%Y-%m-%d %H:%M:%S")

                        entree = {
                            'ligne': numero_ligne,
                            'timestamp': timestamp,
                            'niveau': donnees['niveau'],
                            'message': donnees['message']
                        }

                        entrees_log.append(entree)
                        statistiques[donnees['niveau']] += 1

                        print(
                            f"   [{numero_ligne:2d}] {donnees['niveau']:<7} : {donnees['message']}")
                    else:
                        print(
                            f"   [{numero_ligne:2d}] ‚ùå Format non reconnu : {ligne}")

        print(f"\n   Statistiques :")
        for niveau, count in statistiques.items():
            if count > 0:
                print(f"      {niveau:<7} : {count}")

        return entrees_log

    except Exception as e:
        print(f"   ‚ùå Erreur : {e}")
        return []


logs_analyses = analyser_logs()

print("\n" + "=" * 50)
print("8. GESTION D'ERREURS AVANC√âE")
print("=" * 50)

print("\nüö® ERREURS COURANTES")
print("-" * 20)


def demo_erreurs_fichiers():
    """D√©monstration des erreurs courantes avec les fichiers"""

    erreurs_courantes = [
        ("FileNotFoundError", "test_files/inexistant.txt", "r"),
        # x √©choue si existe
        ("PermissionError", "test_files/exemple_simple.txt", "x"),
        ("IsADirectoryError", "test_files", "r"),  # Essayer d'ouvrir un dossier
        ("UnicodeDecodeError", "test_files/test_utf_16.txt", "r", "ascii"),
    ]

    print("üö® Tests d'erreurs courantes :")

    for erreur_attendue, fichier, mode, *args in erreurs_courantes:
        encoding = args[0] if args else "utf-8"

        try:
            print(f"\n   Test {erreur_attendue} :")
            print(f"      Fichier : {fichier}")
            print(f"      Mode : {mode}, Encoding : {encoding}")

            with open(fichier, mode, encoding=encoding) as f:
                contenu = f.read(10)
                print(f"      ‚úÖ Succ√®s inattendu : '{contenu}'")

        except FileNotFoundError as e:
            print(f"      ‚ùå FileNotFoundError : {e}")
        except PermissionError as e:
            print(f"      ‚ùå PermissionError : {e}")
        except IsADirectoryError as e:
            print(f"      ‚ùå IsADirectoryError : {e}")
        except UnicodeDecodeError as e:
            print(f"      ‚ùå UnicodeDecodeError : {e}")
        except Exception as e:
            print(f"      ‚ùå Autre erreur ({type(e).__name__}) : {e}")


demo_erreurs_fichiers()

print("\nüõ°Ô∏è GESTION ROBUSTE")
print("-" * 19)


def lecteur_fichier_robuste(nom_fichier, encodages_test=None, max_taille=10*1024*1024):
    """Lecteur de fichier robuste avec fallbacks"""

    if encodages_test is None:
        encodages_test = ['utf-8', 'cp1252', 'iso-8859-1']

    print(f"üõ°Ô∏è Lecture robuste de '{nom_fichier}' :")

    # V√©rifications pr√©liminaires
    try:
        if not os.path.exists(nom_fichier):
            raise FileNotFoundError(f"Fichier non trouv√© : {nom_fichier}")

        if os.path.isdir(nom_fichier):
            raise IsADirectoryError(f"'{nom_fichier}' est un r√©pertoire")

        taille = os.path.getsize(nom_fichier)
        print(f"   üìä Taille : {taille:,} octets")

        if taille > max_taille:
            raise ValueError(
                f"Fichier too volumineux : {taille:,} > {max_taille:,} octets")

        if taille == 0:
            print("   ‚ö†Ô∏è Fichier vide")
            return ""

    except Exception as e:
        print(f"   ‚ùå V√©rification √©chou√©e : {e}")
        return None

    # Tentatives de lecture avec diff√©rents encodages
    for encodage in encodages_test:
        try:
            print(f"   üîç Tentative avec encodage '{encodage}'...")

            with open(nom_fichier, "r", encoding=encodage) as f:
                contenu = f.read()

            print(f"   ‚úÖ Succ√®s avec '{encodage}' : {len(contenu)} caract√®res")
            return contenu

        except UnicodeDecodeError as e:
            print(f"   ‚ùå √âchec '{encodage}' : {e}")
            continue
        except Exception as e:
            print(f"   ‚ùå Erreur '{encodage}' : {e}")
            break

    # Fallback : lecture binaire
    try:
        print("   üîÑ Fallback : lecture binaire...")
        with open(nom_fichier, "rb") as f:
            contenu_binaire = f.read()

        print(f"   ‚úÖ Lecture binaire r√©ussie : {len(contenu_binaire)} octets")
        return contenu_binaire

    except Exception as e:
        print(f"   ‚ùå √âchec lecture binaire : {e}")
        return None


# Tests de lecture robuste
print("üõ°Ô∏è Tests de lecture robuste :")
lecteur_fichier_robuste("test_files/exemple_simple.txt")
print()
lecteur_fichier_robuste("test_files/inexistant.txt")
print()
lecteur_fichier_robuste("test_files")  # R√©pertoire

print("\nüîÑ RETRY ET TIMEOUT")
print("-" * 20)


def lire_fichier_avec_retry(nom_fichier, max_tentatives=3, delai=0.1):
    """Lecture avec syst√®me de retry"""
    import time

    print(f"üîÑ Lecture avec retry de '{nom_fichier}' :")

    for tentative in range(1, max_tentatives + 1):
        try:
            print(f"   Tentative {tentative}/{max_tentatives}")

            # Simuler des conditions instables
            if tentative < 2:  # Premi√®re tentative √©choue (simulation)
                # Ici on pourrait avoir des erreurs r√©seau, verrous, etc.
                pass

            with open(nom_fichier, "r", encoding="utf-8") as f:
                contenu = f.read()

            print(f"   ‚úÖ Succ√®s √† la tentative {tentative}")
            return contenu

        except Exception as e:
            print(f"   ‚ùå Tentative {tentative} √©chou√©e : {e}")

            if tentative == max_tentatives:
                print(
                    f"   üí• √âchec d√©finitif apr√®s {max_tentatives} tentatives")
                raise

            print(f"   ‚è≥ Attente de {delai}s...")
            time.sleep(delai)
            delai *= 2  # Backoff exponentiel


# Test du retry (succ√®s)
try:
    contenu = lire_fichier_avec_retry("test_files/exemple_simple.txt")
    print(f"   üìù Contenu r√©cup√©r√© : {len(contenu)} caract√®res\n")
except Exception as e:
    print(f"   ‚ùå √âchec final : {e}\n")

print("\n" + "=" * 50)
print("9. OPTIMISATION ET PERFORMANCE")
print("=" * 50)

print("\n‚ö° BUFFERING")
print("-" * 11)


def demo_buffering():
    """D√©monstration de l'impact du buffering"""
    import time

    print("‚ö° Impact du buffering sur les performances :")

    # Cr√©er un fichier de test plus volumineux
    nom_fichier = "test_files/gros_fichier_perf.txt"
    taille_cible = 50000  # 50k lignes

    print(f"   Cr√©ation d'un fichier de {taille_cible} lignes...")
    with open(nom_fichier, "w", encoding="utf-8") as f:
        for i in range(taille_cible):
            f.write(
                f"Ligne {i:05d} : Contenu de test pour mesurer les performances de lecture\n")

    # Test avec diff√©rentes tailles de buffer
    buffers_test = [
        (-1, "Par d√©faut"),
        (0, "Non bufferis√©"),
        (1024, "1 KB"),
        (8192, "8 KB"),
        (65536, "64 KB"),
    ]

    for taille_buffer, description in buffers_test:
        try:
            start_time = time.time()
            lignes_lues = 0

            with open(nom_fichier, "r", encoding="utf-8", buffering=taille_buffer) as f:
                for ligne in f:
                    lignes_lues += 1

            duree = time.time() - start_time
            print(
                f"   Buffer{taille_buffer:>6} ({description:<12}) : {duree:.3f}s ({lignes_lues} lignes)")

        except Exception as e:
            print(f"   Buffer{taille_buffer:>6} : ‚ùå {e}")


demo_buffering()

print("\nüîç LECTURE S√âLECTIVE")
print("-" * 21)


def demo_lecture_selective():
    """Techniques de lecture s√©lective pour gros fichiers"""

    print("üîç Techniques de lecture s√©lective :")

    nom_fichier = "test_files/gros_fichier_perf.txt"

    # 1. Lire seulement les N premi√®res lignes
    print("   1. Premi√®res lignes seulement :")
    with open(nom_fichier, "r", encoding="utf-8") as f:
        for i, ligne in enumerate(f):
            if i >= 5:  # Arr√™ter apr√®s 5 lignes
                break
            print(f"      [{i+1}] {ligne.strip()}")

    # 2. Lire une ligne sur N
    print("\n   2. Une ligne sur 10000 :")
    with open(nom_fichier, "r", encoding="utf-8") as f:
        for i, ligne in enumerate(f):
            if i % 10000 == 0:  # Une ligne sur 10000
                print(f"      [{i+1}] {ligne.strip()}")
                if i > 40000:  # Limiter pour la d√©mo
                    break

    # 3. Chercher des lignes sp√©cifiques
    print("\n   3. Lignes contenant '00000' :")
    with open(nom_fichier, "r", encoding="utf-8") as f:
        for i, ligne in enumerate(f):
            if '00000' in ligne:
                print(f"      [{i+1}] {ligne.strip()}")

    # 4. Lire √† partir d'une position
    print("\n   4. Lecture √† partir du milieu du fichier :")
    with open(nom_fichier, "r", encoding="utf-8") as f:
        # Aller au milieu approximatif
        f.seek(0, 2)  # Fin du fichier
        taille = f.tell()
        f.seek(taille // 2)  # Milieu

        # Aller au d√©but de la ligne suivante
        f.readline()  # Ignorer la ligne potentiellement coup√©e

        # Lire quelques lignes
        for i in range(3):
            ligne = f.readline()
            if ligne:
                print(f"      [milieu+{i+1}] {ligne.strip()}")


demo_lecture_selective()

print("\nüíæ MEMORY MAPPING")
print("-" * 17)


def demo_memory_mapping():
    """D√©monstration du memory mapping pour gros fichiers"""
    import mmap

    print("üíæ Memory mapping pour gros fichiers :")

    nom_fichier = "test_files/gros_fichier_perf.txt"

    try:
        with open(nom_fichier, "r", encoding="utf-8") as f:
            # Memory mapping en mode lecture
            with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mm:
                print(f"   üìä Taille mapp√©e : {len(mm):,} octets")

                # Lire les premiers caract√®res
                debut = mm[:100].decode('utf-8')
                print(f"   üìñ D√©but : '{debut.replace(chr(10), '\\n')}'")

                # Chercher dans le fichier mapp√©
                position = mm.find(b'30000')
                if position != -1:
                    print(f"   üîç '30000' trouv√© √† la position {position}")

                    # Lire autour de cette position
                    debut_ligne = mm.rfind(b'\n', 0, position) + 1
                    fin_ligne = mm.find(b'\n', position)
                    ligne = mm[debut_ligne:fin_ligne].decode('utf-8')
                    print(f"   üìù Ligne trouv√©e : '{ligne}'")

                # Statistiques
                nb_lignes = mm.count(b'\n')
                print(f"   üìä Nombre de lignes : {nb_lignes:,}")

    except Exception as e:
        print(f"   ‚ùå Erreur memory mapping : {e}")


demo_memory_mapping()

print("\n" + "=" * 50)
print("10. EXERCICES PRATIQUES")
print("=" * 50)

print("""
üí™ EXERCICES √Ä IMPL√âMENTER :

üéØ Exercice 1 : Analyseur de logs web
Cr√©ez un analyseur pour des logs Apache/Nginx :
‚Ä¢ Parsing des lignes avec regex
‚Ä¢ Extraction IP, timestamp, code de r√©ponse, taille
‚Ä¢ Statistiques par heure/jour
‚Ä¢ Top des pages visit√©es
‚Ä¢ D√©tection d'attaques (404 r√©p√©t√©s, etc.)

üìä Exercice 2 : Convertisseur de formats
Cr√©ez un convertisseur CSV/JSON/XML :
‚Ä¢ D√©tection automatique du format source
‚Ä¢ Validation de structure
‚Ä¢ Conversion avec pr√©servation des types
‚Ä¢ Gestion des erreurs par ligne
‚Ä¢ Progress bar pour gros fichiers

üîç Exercice 3 : Moniteur de fichiers
Cr√©ez un moniteur de fichiers en temps r√©el :
‚Ä¢ Watch de r√©pertoires avec watchdog
‚Ä¢ Lecture incr√©mentale (tail -f like)
‚Ä¢ Filtrage par patterns
‚Ä¢ Alertes sur conditions
‚Ä¢ Rotation de logs automatique

üìã Exercice 4 : Gestionnaire de configuration
Cr√©ez un syst√®me de configuration multi-format :
‚Ä¢ Support JSON, YAML, INI, TOML
‚Ä¢ Validation avec sch√©mas
‚Ä¢ Merge de configurations
‚Ä¢ Variables d'environnement
‚Ä¢ Hot-reload des changements

üéÆ Exercice 5 : Parser de donn√©es scientifiques
Cr√©ez un parser pour donn√©es exp√©rimentales :
‚Ä¢ Formats binaires et texte
‚Ä¢ M√©tadonn√©es et payload
‚Ä¢ Validation d'int√©grit√©
‚Ä¢ Export vers diff√©rents formats
‚Ä¢ Visualisation des donn√©es
""")

print("\n" + "=" * 50)
print("11. R√âSUM√â FINAL")
print("=" * 50)

print("""
üéØ POINTS CL√âS √Ä RETENIR :

1. üìÇ OUVERTURE DE FICHIERS :
   ‚Ä¢ open(file, mode, encoding) : fonction de base
   ‚Ä¢ Modes : 'r' (lecture), 'w' (√©criture), 'a' (ajout)
   ‚Ä¢ Toujours sp√©cifier encoding='utf-8'
   ‚Ä¢ Context managers (with) obligatoires

2. üìñ M√âTHODES DE LECTURE :
   ‚Ä¢ read() : contenu complet
   ‚Ä¢ read(size) : lecture par blocs
   ‚Ä¢ readline() : ligne par ligne
   ‚Ä¢ readlines() : toutes les lignes en liste
   ‚Ä¢ It√©ration directe : for ligne in f (recommand√©)

3. üéØ GESTION DE POSITION :
   ‚Ä¢ tell() : position courante
   ‚Ä¢ seek(pos) : aller √† une position
   ‚Ä¢ seek(offset, whence) : relatif (0=d√©but, 1=courant, 2=fin)
   ‚Ä¢ Position en octets, pas en caract√®res !

4. üåç ENCODAGE :
   ‚Ä¢ UTF-8 : recommand√© pour tous les nouveaux fichiers
   ‚Ä¢ Erreurs d'encodage : strict, ignore, replace
   ‚Ä¢ D√©tection : tester plusieurs encodages
   ‚Ä¢ Binaire vs texte : modes 'b' vs 't'

5. üîí S√âCURIT√â ET ROBUSTESSE :
   ‚Ä¢ With statements pour cleanup automatique
   ‚Ä¢ Gestion d'erreurs sp√©cifiques
   ‚Ä¢ Validation de taille et existence
   ‚Ä¢ Retry avec backoff pour instabilit√©s

üí° BONNES PRATIQUES :
‚úÖ Toujours utiliser with pour ouvrir des fichiers
‚úÖ Sp√©cifier l'encodage explicitement
‚úÖ G√©rer les erreurs sp√©cifiques (FileNotFound, etc.)
‚úÖ Valider la taille pour √©viter les OOM
‚úÖ Fermer les fichiers m√™me en cas d'erreur
‚úÖ Pr√©f√©rer l'it√©ration √† readlines() pour gros fichiers

üö® ERREURS COURANTES :
‚ùå Oublier de fermer les fichiers
‚ùå Ignorer l'encodage (probl√®mes avec caract√®res sp√©ciaux)
‚ùå Charger de gros fichiers enti√®rement en m√©moire
‚ùå Ne pas g√©rer les erreurs d'ouverture
‚ùå Utiliser seek() incorrectement en mode texte
‚ùå M√©langer modes binaire et texte

‚ö° OPTIMISATIONS :
‚Ä¢ Buffering appropri√© pour les performances
‚Ä¢ Lecture s√©lective pour gros fichiers
‚Ä¢ Memory mapping pour acc√®s al√©atoire
‚Ä¢ Streaming pour traitement en pipeline
‚Ä¢ Parall√©lisation pour traitement multiple

üîß FORMATS SP√âCIALIS√âS :
‚Ä¢ CSV : module csv pour parsing robuste
‚Ä¢ JSON : module json pour s√©rialisation
‚Ä¢ XML : lxml ou xml.etree pour parsing
‚Ä¢ Binaires : struct pour d√©composition
‚Ä¢ Logs : regex pour extraction de donn√©es

üéØ PATTERNS AVANC√âS :
‚Ä¢ Context managers personnalis√©s
‚Ä¢ Retry automatique avec backoff
‚Ä¢ Progress tracking pour gros fichiers
‚Ä¢ Validation en streaming
‚Ä¢ Conversion de formats √† la vol√©e

üîç DEBUGGING :
‚Ä¢ V√©rifier l'encodage avec hexdump
‚Ä¢ Tester avec petits √©chantillons
‚Ä¢ Logging des erreurs de lecture
‚Ä¢ Validation des assumptions sur le format
‚Ä¢ Tests avec fichiers corrompus

üéâ F√©licitations ! Lecture de fichiers ma√Ætris√©e !
üí° Prochaine √©tape : √âcriture de fichiers !
üìö Lecture ma√Ætris√©e, √©crivez maintenant !
""")

print("\n" + "=" * 70)
print("üéØ FIN DU GUIDE - LECTURE DE FICHIERS MA√éTRIS√âE !")
print("=" * 70)
