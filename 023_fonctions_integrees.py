#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
======================================================================
FONCTIONS BUILT-IN DE PYTHON - GUIDE COMPLET
======================================================================

üéØ Ce fichier couvre les fonctions int√©gr√©es de Python :
   ‚Ä¢ Fonctions math√©matiques et num√©riques
   ‚Ä¢ Fonctions de conversion et casting
   ‚Ä¢ Fonctions d'it√©ration et s√©quences
   ‚Ä¢ Fonctions d'introspection
   ‚Ä¢ Fonctions d'I/O et syst√®me
   ‚Ä¢ Fonctions avanc√©es et sp√©cialis√©es

üìö Concepts abord√©s :
   ‚Ä¢ Built-ins les plus utilis√©es
   ‚Ä¢ Combinaisons et patterns
   ‚Ä¢ Performance et optimisation
   ‚Ä¢ Cas d'usage sp√©cifiques
   ‚Ä¢ Alternatives et bonnes pratiques

üí° Objectif : Ma√Ætriser l'arsenal des fonctions int√©gr√©es Python
"""

import time
import sys
import io

print("=" * 70)
print("FONCTIONS BUILT-IN DE PYTHON - GUIDE COMPLET")
print("=" * 70)

print("\n" + "=" * 50)
print("1. FONCTIONS MATH√âMATIQUES ET NUM√âRIQUES")
print("=" * 50)

print("\nüî¢ FONCTIONS NUM√âRIQUES DE BASE")
print("-" * 29)

# Donn√©es de test
nombres_test = [-5, -3.7, 0, 2.8, 7, 12.5]
print(f"üìä Donn√©es de test : {nombres_test}")

print("\nüßÆ Fonctions math√©matiques essentielles :")

# abs() - Valeur absolue
valeurs_absolues = [abs(x) for x in nombres_test]
print(f"   abs() : {valeurs_absolues}")

# round() - Arrondi
arrondis = [round(x) for x in nombres_test]
print(f"   round() : {arrondis}")

# round() avec pr√©cision
arrondis_precis = [round(x, 1) for x in nombres_test]
print(f"   round(x, 1) : {arrondis_precis}")

# min() et max()
minimum = min(nombres_test)
maximum = max(nombres_test)
print(f"   min() : {minimum}")
print(f"   max() : {maximum}")

# sum()
somme_totale = sum(nombres_test)
print(f"   sum() : {somme_totale}")

# pow() - Puissance
print(f"   pow(2, 3) : {pow(2, 3)}")
print(f"   pow(2, 3, 5) : {pow(2, 3, 5)}")  # (2¬≥) mod 5

print("\nüî§ FONCTIONS DE CONVERSION")
print("-" * 25)

# Donn√©es mixtes pour conversion
donnees_mixtes = [42, 3.14, "123", "45.67", True, False]
print(f"üìä Donn√©es mixtes : {donnees_mixtes}")

print("\nüîÑ Conversions de types :")

# int() - Conversion en entier
print("   int() conversions :")
for donnee in donnees_mixtes:
    try:
        resultat = int(donnee) if isinstance(
            donnee, (str, float, bool)) else int(float(str(donnee)))
        print(f"     int({donnee}) = {resultat}")
    except ValueError as e:
        print(f"     int({donnee}) = Erreur : {e}")

# float() - Conversion en flottant
print("\n   float() conversions :")
for donnee in donnees_mixtes:
    try:
        if isinstance(donnee, str):
            resultat = float(donnee)
        else:
            resultat = float(donnee)
        print(f"     float({donnee}) = {resultat}")
    except ValueError as e:
        print(f"     float({donnee}) = Erreur : {e}")

# str() - Conversion en cha√Æne
conversions_str = [str(x) for x in donnees_mixtes]
print(f"\n   str() : {conversions_str}")

# bool() - Conversion en bool√©en
print("\n   bool() conversions (valeurs falsy/truthy) :")
valeurs_test_bool = [0, 1, "", "hello", [], [1, 2], {}, {"a": 1}, None]
for valeur in valeurs_test_bool:
    resultat = bool(valeur)
    print(f"     bool({valeur}) = {resultat}")

print("\nüéØ FONCTIONS NUM√âRIQUES AVANC√âES")
print("-" * 31)

# divmod() - Division et modulo
print("üéØ divmod() - Division euclidienne :")
divisions_test = [(17, 5), (23, 7), (100, 13)]
for a, b in divisions_test:
    quotient, reste = divmod(a, b)
    print(
        f"   divmod({a}, {b}) = ({quotient}, {reste}) -> {a} = {b}√ó{quotient} + {reste}")

# bin(), oct(), hex() - Conversions de base
nombre_conv = 42
print(f"\nüî¢ Conversions de base pour {nombre_conv} :")
print(f"   bin({nombre_conv}) = {bin(nombre_conv)}")
print(f"   oct({nombre_conv}) = {oct(nombre_conv)}")
print(f"   hex({nombre_conv}) = {hex(nombre_conv)}")

# Conversion inverse
print(f"\nüîÑ Conversions inverses :")
print(f"   int('0b101010', 2) = {int('0b101010', 2)}")
print(f"   int('0o52', 8) = {int('0o52', 8)}")
print(f"   int('0x2a', 16) = {int('0x2a', 16)}")

print("\n" + "=" * 50)
print("2. FONCTIONS D'IT√âRATION ET S√âQUENCES")
print("=" * 50)

print("\nüìã ENUMERATE() - INDEXATION")
print("-" * 26)

fruits = ["pomme", "banane", "orange", "kiwi"]
print(f"üìã Liste : {fruits}")

print("\nüî¢ enumerate() ajoute des indices :")
for index, fruit in enumerate(fruits):
    print(f"   {index} : {fruit}")

print("\nüéØ enumerate() avec start personnalis√© :")
for index, fruit in enumerate(fruits, start=1):
    print(f"   #{index} : {fruit}")

# Utilisation pratique : trouver l'index d'un √©l√©ment


def trouver_index(liste, element):
    """Trouve l'index d'un √©l√©ment avec enumerate"""
    for index, item in enumerate(liste):
        if item == element:
            return index
    return -1


index_orange = trouver_index(fruits, "orange")
print(f"\n   Index de 'orange' : {index_orange}")

print("\nüîó ZIP() - COMBINAISON DE S√âQUENCES")
print("-" * 33)

noms = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
villes = ["Paris", "Lyon", "Marseille"]

print(f"üìä Donn√©es parall√®les :")
print(f"   Noms : {noms}")
print(f"   √Çges : {ages}")
print(f"   Villes : {villes}")

print("\nüîó zip() combine les s√©quences :")
for nom, age, ville in zip(noms, ages, villes):
    print(f"   {nom}, {age} ans, vit √† {ville}")

# zip() avec longueurs diff√©rentes
scores = [85, 92]  # Plus court
print(f"\n‚ö†Ô∏è zip() s'arr√™te au plus court :")
print(f"   Scores : {scores}")
for nom, score in zip(noms, scores):
    print(f"   {nom} : {score}")

# Cr√©ation de dictionnaire avec zip
profils = dict(zip(noms, ages))
print(f"\nüìñ Dictionnaire cr√©√© avec zip : {profils}")

# D√©ballage avec zip (transposition)
donnees_transposees = list(zip(*zip(noms, ages, villes)))
print(f"\nüîÑ Transposition avec zip(*zip(...)) :")
print(f"   Originale : {list(zip(noms, ages, villes))}")
print(f"   Transpos√©e : {donnees_transposees}")

print("\nüìè RANGE() - G√âN√âRATION DE S√âQUENCES")
print("-" * 35)

print("üìè range() g√©n√®re des s√©quences num√©riques :")

# range() basique
print(f"   range(5) : {list(range(5))}")
print(f"   range(2, 8) : {list(range(2, 8))}")
print(f"   range(0, 10, 2) : {list(range(0, 10, 2))}")
print(f"   range(10, 0, -1) : {list(range(10, 0, -1))}")

# Utilisation avec autres fonctions
print(f"\nüî¢ Combinaisons avec range() :")
print(f"   sum(range(1, 6)) : {sum(range(1, 6))}")  # 1+2+3+4+5
print(f"   max(range(10, 0, -2)) : {max(range(10, 0, -2))}")

# G√©n√©ration de coordonn√©es
coordonnees = [(x, y) for x in range(3) for y in range(3)]
print(f"   Coordonn√©es 3√ó3 : {coordonnees}")

print("\nüîÑ REVERSED() - INVERSION")
print("-" * 24)

# reversed() sur diff√©rents types
donnees_reverse = [1, 2, 3, 4, 5]
chaine_reverse = "Python"

print("üîÑ reversed() inverse les s√©quences :")
print(f"   Liste originale : {donnees_reverse}")
print(f"   Liste invers√©e : {list(reversed(donnees_reverse))}")
print(f"   Cha√Æne originale : {chaine_reverse}")
print(f"   Cha√Æne invers√©e : {''.join(reversed(chaine_reverse))}")

# reversed() avec enumerate
print(f"\nüìã enumerate() + reversed() :")
for index, valeur in enumerate(reversed(donnees_reverse)):
    print(f"   Position {index} (depuis la fin) : {valeur}")

print("\nüìä SORTED() - TRI AVANC√â")
print("-" * 22)

# Donn√©es complexes pour tri
etudiants = [
    {"nom": "Alice", "note": 15, "age": 20},
    {"nom": "Bob", "note": 18, "age": 19},
    {"nom": "Charlie", "note": 12, "age": 21},
    {"nom": "Diana", "note": 16, "age": 18}
]

print("üìä sorted() avec donn√©es complexes :")
print("   √âtudiants originaux :")
for etudiant in etudiants:
    print(f"     {etudiant}")

# Tri par note
par_note = sorted(etudiants, key=lambda e: e["note"])
print(
    f"\n   Tri par note : {[e['nom'] + ':' + str(e['note']) for e in par_note]}")

# Tri par √¢ge d√©croissant
par_age_desc = sorted(etudiants, key=lambda e: e["age"], reverse=True)
print(
    f"   Tri par √¢ge ‚Üì : {[e['nom'] + ':' + str(e['age']) for e in par_age_desc]}")

# Tri par multiple crit√®res
par_criteres = sorted(etudiants, key=lambda e: (-e["note"], e["age"]))
print(
    f"   Tri note ‚Üì, √¢ge ‚Üë : {[e['nom'] + ':' + str(e['note']) + ':' + str(e['age']) for e in par_criteres]}")

print("\n" + "=" * 50)
print("3. FONCTIONS D'ENTR√âE/SORTIE")
print("=" * 50)

print("\nüí¨ INPUT() - SAISIE UTILISATEUR")
print("-" * 27)

print("""
üí¨ input() capture la saisie utilisateur :

# Exemples (code non ex√©cut√© ici) :
# nom = input("Votre nom : ")
# age = int(input("Votre √¢ge : "))
# prix = float(input("Prix : "))

‚ö†Ô∏è input() retourne toujours une cha√Æne !
‚û°Ô∏è Conversion n√©cessaire pour nombres
""")

# Simulation de saisies utilisateur


def simuler_input(prompt, valeur_simulee):
    """Simule input() pour les d√©monstrations"""
    print(f"{prompt}{valeur_simulee}")
    return valeur_simulee


print("üéØ Simulation de saisies :")
nom_simule = simuler_input("Nom : ", "Alice")
age_simule = int(simuler_input("√Çge : ", "25"))
actif_simule = simuler_input("Actif (oui/non) : ", "oui").lower() == "oui"

print(
    f"   R√©sultats : nom='{nom_simule}', √¢ge={age_simule}, actif={actif_simule}")

print("\nüñ®Ô∏è PRINT() - SORTIE FORMAT√âE")
print("-" * 25)

print("üñ®Ô∏è print() options avanc√©es :")

# S√©parateur personnalis√©
print("Option sep :", end="")
print("A", "B", "C", sep=" | ")

# Terminaison personnalis√©e
print("Option end :", end="")
print("Ligne 1", end=" -> ")
print("Suite de la ligne")

# Redirection vers fichier (simulation)

buffer = io.StringIO()
print("Redirection vers buffer", file=buffer)
contenu_buffer = buffer.getvalue()
print(f"   Contenu captur√© : '{contenu_buffer.strip()}'")

# Formatage avec f-strings
nom, age, salaire = "Bob", 30, 45000.50
print(f"   f-string : {nom} a {age} ans et gagne {salaire:.2f}‚Ç¨")

# Print avec flush (force l'√©criture imm√©diate)
print("   flush=True force l'√©criture imm√©diate", flush=True)

print("\nüìÑ FORMAT() - FORMATAGE AVANC√â")
print("-" * 28)

# Exemples de formatage
valeur = 1234.5678
print("üìÑ format() - formatage de nombres :")
print(f"   format({valeur}, '.2f') = {format(valeur, '.2f')}")
print(f"   format({valeur}, '.2e') = {format(valeur, '.2e')}")
print(f"   format({valeur}, '.2%') = {format(valeur/100, '.2%')}")
print(f"   format({int(valeur)}, 'b') = {format(int(valeur), 'b')}")
print(f"   format({int(valeur)}, 'x') = {format(int(valeur), 'x')}")

# Formatage avec largeur et alignement
texte = "Python"
print(f"\nüìê Formatage avec alignement :")
print(f"   format('{texte}', '<10') = '{format(texte, '<10')}'")  # Gauche
print(f"   format('{texte}', '^10') = '{format(texte, '^10')}'")  # Centre
print(f"   format('{texte}', '>10') = '{format(texte, '>10')}'")  # Droite
# Remplissage
print(f"   format('{texte}', '*^10') = '{format(texte, '*^10')}'")

print("\n" + "=" * 50)
print("4. FONCTIONS D'INTROSPECTION")
print("=" * 50)

print("\nüîç TYPE() ET ISINSTANCE()")
print("-" * 24)

# Diff√©rents types d'objets
objets_test = [42, 3.14, "hello", [1, 2, 3], {"a": 1}, (1, 2), {1, 2, 3}, None]

print("üîç Introspection de types :")
for obj in objets_test:
    type_obj = type(obj)
    nom_type = type_obj.__name__
    print(f"   {obj} -> type: {nom_type}")

# isinstance() vs type()
print(f"\nüéØ isinstance() vs type() :")
nombre = 42
print(f"   type({nombre}) == int : {type(nombre) == int}")
print(f"   isinstance({nombre}, int) : {isinstance(nombre, int)}")
print(
    f"   isinstance({nombre}, (int, float)) : {isinstance(nombre, (int, float))}")

# isinstance() avec h√©ritage


class Animal:
    pass


class Chien(Animal):
    pass


mon_chien = Chien()
print(f"\nüêï Test d'h√©ritage :")
print(f"   isinstance(chien, Chien) : {isinstance(mon_chien, Chien)}")
print(f"   isinstance(chien, Animal) : {isinstance(mon_chien, Animal)}")
print(f"   type(chien) == Animal : {type(mon_chien) == Animal}")

print("\nüìñ DIR() - EXPLORATION D'OBJETS")
print("-" * 29)

# dir() sur diff√©rents objets
print("üìñ dir() liste les attributs et m√©thodes :")

# String
methodes_str = [m for m in dir("") if not m.startswith('_')]
print(f"   M√©thodes str (√©chantillon) : {methodes_str[:8]}...")

# List
methodes_list = [m for m in dir([]) if not m.startswith('_')]
print(f"   M√©thodes list : {methodes_list}")

# Objet personnalis√©


class Exemple:
    attribut_classe = "classe"

    def __init__(self):
        self.attribut_instance = "instance"

    def methode_exemple(self):
        pass


obj_exemple = Exemple()
attributs_exemple = [attr for attr in dir(
    obj_exemple) if not attr.startswith('_')]
print(f"   Attributs Exemple : {attributs_exemple}")

print("\nüè∑Ô∏è HASATTR(), GETATTR(), SETATTR()")
print("-" * 35)

print("üè∑Ô∏è Manipulation d'attributs dynamique :")

# hasattr() - Test d'existence
print(
    f"   hasattr(obj_exemple, 'attribut_instance') : {hasattr(obj_exemple, 'attribut_instance')}")
print(
    f"   hasattr(obj_exemple, 'inexistant') : {hasattr(obj_exemple, 'inexistant')}")

# getattr() - R√©cup√©ration avec d√©faut
valeur_existante = getattr(obj_exemple, 'attribut_instance', 'd√©faut')
valeur_inexistante = getattr(obj_exemple, 'inexistant', 'd√©faut')
print(f"   getattr(obj, 'attribut_instance', 'd√©faut') : {valeur_existante}")
print(f"   getattr(obj, 'inexistant', 'd√©faut') : {valeur_inexistante}")

# setattr() - D√©finition dynamique
setattr(obj_exemple, 'nouvel_attribut', 'nouvelle_valeur')
print(f"   Apr√®s setattr() : {obj_exemple.nouvel_attribut}")

# delattr() - Suppression
# delattr(obj_exemple, 'nouvel_attribut')  # D√©commentez pour tester

print("\nüÜî ID() ET HASH()")
print("-" * 16)

# id() - Identit√© d'objet
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print("üÜî Identit√© d'objets avec id() :")
print(f"   a = {a}, id = {id(a)}")
print(f"   b = a, id = {id(b)} -> m√™me objet ? {id(a) == id(b)}")
print(f"   c = [1,2,3], id = {id(c)} -> m√™me objet ? {id(a) == id(c)}")

# hash() - Empreinte
objets_hashables = [42, "hello", (1, 2, 3), frozenset([1, 2, 3])]
print(f"\nüîê Hash d'objets :")
for obj in objets_hashables:
    try:
        h = hash(obj)
        print(f"   hash({obj}) = {h}")
    except TypeError as e:
        print(f"   hash({obj}) = Erreur : {e}")

print("\n" + "=" * 50)
print("5. FONCTIONS DE MANIPULATION D'OBJETS")
print("=" * 50)

print("\nüì¶ LEN() - TAILLE D'OBJETS")
print("-" * 22)

# len() sur diff√©rents types
objets_taille = [
    [1, 2, 3, 4, 5],
    "Python",
    {"a": 1, "b": 2, "c": 3},
    (1, 2, 3, 4),
    {1, 2, 3, 4, 5, 6},
    range(10)
]

print("üì¶ len() mesure la taille :")
for obj in objets_taille:
    taille = len(obj)
    type_nom = type(obj).__name__
    print(f"   len({obj}) = {taille} ({type_nom})")

print("\nüßÆ ALL() ET ANY()")
print("-" * 17)

# Donn√©es pour tests logiques
tests_bool = [
    [True, True, True],
    [True, False, True],
    [False, False, False],
    [],
    [1, 2, 3, 4],
    [0, 1, 2, 3],
    ["", "hello", "world"],
    ["hello", "world"]
]

print("üßÆ all() et any() - tests logiques :")
for test in tests_bool:
    all_result = all(test)
    any_result = any(test)
    print(f"   {test}")
    print(f"     all() = {all_result}, any() = {any_result}")

# Utilisation pratique
notes = [12, 15, 18, 14, 16]
print(f"\nüéØ Applications pratiques :")
print(f"   Notes : {notes}")
print(f"   Toutes >= 10 ? {all(note >= 10 for note in notes)}")
print(f"   Au moins une >= 15 ? {any(note >= 15 for note in notes)}")

# Validation de donn√©es
users = [
    {"nom": "Alice", "actif": True, "age": 25},
    {"nom": "Bob", "actif": True, "age": 30},
    {"nom": "Charlie", "actif": False, "age": 22}
]

tous_actifs = all(user["actif"] for user in users)
au_moins_un_majeur = any(user["age"] >= 18 for user in users)
print(f"   Tous actifs ? {tous_actifs}")
print(f"   Au moins un majeur ? {au_moins_un_majeur}")

print("\nüîÄ ITER() ET NEXT()")
print("-" * 18)

# Cr√©ation d'it√©rateur
ma_liste = [1, 2, 3, 4, 5]
iterateur = iter(ma_liste)

print("üîÄ iter() et next() - it√©ration manuelle :")
print(f"   Liste : {ma_liste}")
print(f"   It√©rateur cr√©√© : {iterateur}")

# Consommation avec next()
print("   Consommation avec next() :")
try:
    for i in range(len(ma_liste) + 1):  # +1 pour tester StopIteration
        valeur = next(iterateur)
        print(f"     next() = {valeur}")
except StopIteration:
    print("     StopIteration atteinte")

# next() avec valeur par d√©faut
nouvel_iterateur = iter([10, 20])
print(f"\n   next() avec d√©faut :")
print(f"     next(iter, 'fini') = {next(nouvel_iterateur, 'fini')}")
print(f"     next(iter, 'fini') = {next(nouvel_iterateur, 'fini')}")
print(f"     next(iter, 'fini') = {next(nouvel_iterateur, 'fini')}")

print("\nüéØ CALLABLE() - TEST DE FONCTION")
print("-" * 31)

# Diff√©rents objets √† tester


def ma_fonction():
    pass


class MaClasse:
    def __call__(self):
        pass


instance_callable = MaClasse()
objets_test_callable = [
    ma_fonction,
    MaClasse,
    instance_callable,
    lambda x: x,
    print,
    42,
    "hello",
    []
]

print("üéØ callable() teste si un objet est appelable :")
for obj in objets_test_callable:
    is_callable = callable(obj)
    nom = getattr(obj, '__name__', str(obj))
    print(f"   callable({nom}) = {is_callable}")

print("\n" + "=" * 50)
print("6. FONCTIONS AVANC√âES")
print("=" * 50)

print("\n‚ö° EVAL() ET EXEC() - √âVALUATION DYNAMIQUE")
print("-" * 40)

print("‚ö° eval() √©value des expressions :")

# eval() - √âvaluation d'expressions
expressions = [
    "2 + 3 * 4",
    "len('Python')",
    "max([1, 5, 3, 9, 2])",
    "'Hello' + ' ' + 'World'"
]

for expr in expressions:
    try:
        resultat = eval(expr)
        print(f"   eval('{expr}') = {resultat}")
    except Exception as e:
        print(f"   eval('{expr}') = Erreur : {e}")

# eval() avec contexte
contexte = {"x": 10, "y": 20, "fruits": ["pomme", "banane"]}
expressions_contexte = [
    "x + y",
    "x ** 2",
    "len(fruits)",
    "fruits[0].upper()"
]

print(f"\nüéØ eval() avec contexte {contexte} :")
for expr in expressions_contexte:
    try:
        resultat = eval(expr, {"__builtins__": {}}, contexte)
        print(f"   eval('{expr}') = {resultat}")
    except Exception as e:
        print(f"   eval('{expr}') = Erreur : {e}")

print(f"\n‚ö†Ô∏è exec() ex√©cute du code (attention √† la s√©curit√©) :")
code_simple = """
resultat_exec = 0
for i in range(5):
    resultat_exec += i ** 2
"""

espace_exec = {}
exec(code_simple, espace_exec)
print(f"   Code ex√©cut√©, r√©sultat : {espace_exec.get('resultat_exec')}")

print("\nüî® COMPILE() - COMPILATION DE CODE")
print("-" * 31)

# compile() pour optimiser l'ex√©cution r√©p√©t√©e
expression_compilee = compile("x ** 2 + 2 * x + 1", "<string>", "eval")
code_compile = compile("print('Code compil√© ex√©cut√©')", "<string>", "exec")

print("üî® compile() pr√©-compile le code :")
print(f"   Expression compil√©e : {expression_compilee}")

# Utilisation du code compil√©
x = 5
resultat_compile = eval(expression_compilee, {"x": x})
print(f"   eval(code_compil√©) avec x={x} = {resultat_compile}")

exec(code_compile)

print("\nüèóÔ∏è VARS() - VARIABLES LOCALES/GLOBALES")
print("-" * 37)


def demonstration_vars():
    """D√©monstration de vars()"""
    var_locale_1 = "valeur1"
    var_locale_2 = 42

    print("üèóÔ∏è vars() retourne les variables :")
    variables_locales = vars()
    print(f"   Variables locales : {list(variables_locales.keys())}")

    # vars() avec objet
    class ExempleVars:
        attr1 = "attribut1"
        attr2 = 123

    obj_vars = ExempleVars()
    obj_vars.attr3 = "attribut3"

    print(f"   vars(objet) : {vars(obj_vars)}")


demonstration_vars()

# vars() sans argument = locals()
print(f"   vars() globales (√©chantillon) : {list(vars().keys())[:5]}...")

print("\nüé≤ GLOBALS() ET LOCALS()")
print("-" * 24)

variable_globale_demo = "Je suis globale"


def demo_globals_locals():
    """D√©monstration de globals() et locals()"""
    variable_locale_demo = "Je suis locale"

    print("üé≤ globals() et locals() :")

    # Acc√®s aux espaces de noms
    print(
        f"   Variable globale via globals() : {globals()['variable_globale_demo']}")
    print(
        f"   Variable locale via locals() : {locals()['variable_locale_demo']}")

    # Modification via globals()
    globals()['nouvelle_globale'] = "Cr√©√©e dynamiquement"

    # Comparaison des tailles
    print(f"   Nombre de variables globales : {len(globals())}")
    print(f"   Nombre de variables locales : {len(locals())}")


demo_globals_locals()
if 'nouvelle_globale' in globals():
    print(f"   Variable cr√©√©e dynamiquement : {globals()['nouvelle_globale']}")
else:
    print("   Variable globale non cr√©√©e")

print("\n" + "=" * 50)
print("7. APPLICATIONS PRATIQUES")
print("=" * 50)

print("\nüîß UTILITAIRES DE D√âVELOPPEMENT")
print("-" * 32)


def debug_helper(obj, nom="objet"):
    """Utilitaire de debugging avec built-ins"""
    print(f"üîß Debug de {nom} :")
    print(f"   Type : {type(obj).__name__}")
    print(f"   Valeur : {obj}")
    print(f"   ID : {id(obj)}")
    print(f"   Taille : {len(obj) if hasattr(obj, '__len__') else 'N/A'}")
    print(f"   Hashable : {hash(obj) if hashable_safe(obj) else 'Non'}")
    print(f"   Callable : {callable(obj)}")

    # Attributs (sans les priv√©s)
    if hasattr(obj, '__dict__') or not isinstance(obj, (int, float, str, bool, type(None))):
        attrs = [attr for attr in dir(obj) if not attr.startswith('_')]
        print(
            f"   Attributs publics : {attrs[:5] if len(attrs) > 5 else attrs}")


def hashable_safe(obj):
    """Test s√©curis√© de hashabilit√©"""
    try:
        hash(obj)
        return True
    except TypeError:
        return False


# Test de l'utilitaire
print("üîß Test de l'utilitaire de debug :")
debug_helper([1, 2, 3], "ma_liste")
debug_helper({"a": 1, "b": 2}, "mon_dict")

print("\nüìä ANALYSE DE DONN√âES AVEC BUILT-INS")
print("-" * 35)


def analyser_donnees(donnees, nom="dataset"):
    """Analyse statistique avec fonctions built-in"""
    print(f"üìä Analyse de {nom} :")

    if not donnees:
        print("   Dataset vide")
        return

    # Statistiques de base
    taille = len(donnees)
    minimum = min(donnees)
    maximum = max(donnees)
    somme = sum(donnees)
    moyenne = somme / taille

    print(f"   Taille : {taille}")
    print(f"   Min/Max : {minimum} / {maximum}")
    print(f"   Somme : {somme}")
    print(f"   Moyenne : {moyenne:.2f}")

    # Analyse des types
    types_presents = set(type(x).__name__ for x in donnees)
    print(f"   Types pr√©sents : {types_presents}")

    # Comptage des valeurs
    if taille <= 20:  # Afficher seulement pour petits datasets
        valeurs_uniques = set(donnees)
        print(f"   Valeurs uniques : {len(valeurs_uniques)}")

        # Fr√©quences simples
        if len(valeurs_uniques) <= 10:
            for valeur in sorted(valeurs_uniques):
                compte = sum(1 for x in donnees if x == valeur)
                print(f"     {valeur} : {compte} fois")


# Tests d'analyse
donnees_test_1 = [1, 2, 3, 4, 5, 3, 2, 4, 1, 5]
donnees_test_2 = [10.5, 20.3, 15.7, 30.1, 25.8]

analyser_donnees(donnees_test_1, "entiers")
print()
analyser_donnees(donnees_test_2, "flottants")

print("\nüéØ VALIDATION DE DONN√âES")
print("-" * 24)


def validateur_universel(donnees, regles):
    """Validateur utilisant les built-ins"""
    resultats = {
        "valide": True,
        "erreurs": [],
        "warnings": [],
        "statistiques": {}
    }

    # R√®gles de validation
    if "non_vide" in regles and regles["non_vide"]:
        if not donnees:
            resultats["erreurs"].append("Donn√©es vides")
            resultats["valide"] = False

    if "type_attendu" in regles:
        type_attendu = regles["type_attendu"]
        if not all(isinstance(x, type_attendu) for x in donnees):
            types_trouves = set(type(x).__name__ for x in donnees)
            resultats["erreurs"].append(
                f"Types incorrects. Attendu: {type_attendu.__name__}, trouv√©s: {types_trouves}")
            resultats["valide"] = False

    if "min_taille" in regles:
        if len(donnees) < regles["min_taille"]:
            resultats["erreurs"].append(
                f"Taille insuffisante: {len(donnees)} < {regles['min_taille']}")
            resultats["valide"] = False

    if "max_taille" in regles:
        if len(donnees) > regles["max_taille"]:
            resultats["warnings"].append(
                f"Taille importante: {len(donnees)} > {regles['max_taille']}")

    if donnees and "valeur_min" in regles:
        min_trouvee = min(donnees)
        if min_trouvee < regles["valeur_min"]:
            resultats["erreurs"].append(
                f"Valeur trop petite: {min_trouvee} < {regles['valeur_min']}")
            resultats["valide"] = False

    if donnees and "valeur_max" in regles:
        max_trouvee = max(donnees)
        if max_trouvee > regles["valeur_max"]:
            resultats["erreurs"].append(
                f"Valeur trop grande: {max_trouvee} > {regles['valeur_max']}")
            resultats["valide"] = False

    # Statistiques
    if donnees:
        resultats["statistiques"] = {
            "taille": len(donnees),
            "min": min(donnees) if all(isinstance(x, (int, float)) for x in donnees) else None,
            "max": max(donnees) if all(isinstance(x, (int, float)) for x in donnees) else None,
            "types": list(set(type(x).__name__ for x in donnees))
        }

    return resultats


# Tests de validation
print("üéØ Tests de validation :")

donnees_valides = [10, 20, 30, 40, 50]
regles_test = {
    "non_vide": True,
    "type_attendu": int,
    "min_taille": 3,
    "max_taille": 10,
    "valeur_min": 0,
    "valeur_max": 100
}

resultat_validation = validateur_universel(donnees_valides, regles_test)
print(f"   Donn√©es valides : {resultat_validation['valide']}")
if resultat_validation["erreurs"]:
    print(f"   Erreurs : {resultat_validation['erreurs']}")
if resultat_validation["warnings"]:
    print(f"   Warnings : {resultat_validation['warnings']}")
print(f"   Stats : {resultat_validation['statistiques']}")

# Test avec donn√©es invalides
donnees_invalides = [200, -10, "hello"]
resultat_invalid = validateur_universel(donnees_invalides, regles_test)
print(f"\n   Donn√©es invalides : {resultat_invalid['valide']}")
print(f"   Erreurs : {resultat_invalid['erreurs']}")

print("\n" + "=" * 50)
print("8. PERFORMANCES ET OPTIMISATIONS")
print("=" * 50)

print("\n‚ö° COMPARAISON DE PERFORMANCES")
print("-" * 31)


def mesurer_performance(func, *args, iterations=10000):
    """Mesure la performance d'une fonction"""
    start = time.time()
    for _ in range(iterations):
        func(*args)
    end = time.time()
    return (end - start) * 1000  # en millisecondes


# Donn√©es de test
grandes_donnees = list(range(1000))

print("‚ö° Comparaison map() vs comprehension :")

# Test map vs comprehension


def avec_map():
    return list(map(lambda x: x * 2, grandes_donnees))


def avec_comprehension():
    return [x * 2 for x in grandes_donnees]


temps_map = mesurer_performance(avec_map)
temps_comp = mesurer_performance(avec_comprehension)

print(f"   map() : {temps_map:.2f}ms")
print(f"   comprehension : {temps_comp:.2f}ms")
print(f"   Ratio : {temps_map/temps_comp:.2f}x")

# Test filter vs comprehension
print(f"\nüîç Comparaison filter() vs comprehension :")


def avec_filter():
    return list(filter(lambda x: x % 2 == 0, grandes_donnees))


def avec_comprehension_filter():
    return [x for x in grandes_donnees if x % 2 == 0]


temps_filter = mesurer_performance(avec_filter)
temps_comp_filter = mesurer_performance(avec_comprehension_filter)

print(f"   filter() : {temps_filter:.2f}ms")
print(f"   comprehension : {temps_comp_filter:.2f}ms")
print(f"   Ratio : {temps_filter/temps_comp_filter:.2f}x")

print("\nüß† OPTIMISATIONS AVEC BUILT-INS")
print("-" * 30)

# any() vs loop manuel pour recherche


def recherche_manuelle(liste, condition):
    """Recherche manuelle avec boucle"""
    for item in liste:
        if condition(item):
            return True
    return False


def recherche_any(liste, condition):
    """Recherche avec any()"""
    return any(condition(item) for item in liste)


# Test de performance
def condition_test(x): return x > 500


donnees_recherche = list(range(1000))

temps_manuel = mesurer_performance(
    recherche_manuelle, donnees_recherche, condition_test)
temps_any = mesurer_performance(
    recherche_any, donnees_recherche, condition_test)

print(f"üß† Recherche d'√©l√©ment :")
print(f"   Boucle manuelle : {temps_manuel:.2f}ms")
print(f"   any() : {temps_any:.2f}ms")
print(
    f"   Am√©lioration : {temps_manuel/temps_any:.2f}x plus rapide avec any()")

# min/max vs sorted


def min_max_sorted(liste):
    """Min/max avec sorted (inefficace)"""
    triee = sorted(liste)
    return triee[0], triee[-1]


def min_max_builtin(liste):
    """Min/max avec built-ins"""
    return min(liste), max(liste)


temps_sorted = mesurer_performance(min_max_sorted, grandes_donnees)
temps_builtin = mesurer_performance(min_max_builtin, grandes_donnees)

print(f"\nüìä Min/Max de {len(grandes_donnees)} √©l√©ments :")
print(f"   Avec sorted() : {temps_sorted:.2f}ms")
print(f"   Avec min/max : {temps_builtin:.2f}ms")
print(f"   Am√©lioration : {temps_sorted/temps_builtin:.2f}x plus rapide")


print("\n" + "=" * 50)
print("1-1. R√âSUM√â FINAL")
print("=" * 50)

print("""
üéØ POINTS CL√âS √Ä RETENIR :

1. üî¢ FONCTIONS MATH√âMATIQUES :
   ‚Ä¢ abs(), round(), min(), max(), sum()
   ‚Ä¢ pow(), divmod()
   ‚Ä¢ bin(), oct(), hex() pour les bases
   ‚Ä¢ int(), float() pour conversions

2. üîÑ FONCTIONS D'IT√âRATION :
   ‚Ä¢ enumerate() pour indexation
   ‚Ä¢ zip() pour combinaison de s√©quences
   ‚Ä¢ range() pour g√©n√©ration num√©rique
   ‚Ä¢ reversed() pour inversion
   ‚Ä¢ sorted() pour tri avanc√©

3. üí¨ ENTR√âES/SORTIES :
   ‚Ä¢ input() pour saisie utilisateur
   ‚Ä¢ print() avec options avanc√©es
   ‚Ä¢ format() pour formatage
   ‚Ä¢ str(), repr() pour repr√©sentation

4. üîç INTROSPECTION :
   ‚Ä¢ type(), isinstance() pour types
   ‚Ä¢ dir() pour exploration
   ‚Ä¢ hasattr(), getattr(), setattr()
   ‚Ä¢ id(), hash() pour identit√©
   ‚Ä¢ vars(), globals(), locals()

5. üßÆ FONCTIONS LOGIQUES :
   ‚Ä¢ all(), any() pour tests bool√©ens
   ‚Ä¢ len() pour taille
   ‚Ä¢ callable() pour test de fonction
   ‚Ä¢ iter(), next() pour it√©ration

6. ‚ö° FONCTIONS AVANC√âES :
   ‚Ä¢ eval(), exec() pour √©valuation
   ‚Ä¢ compile() pour optimisation
   ‚Ä¢ map(), filter(), reduce()
   ‚Ä¢ Built-ins vs alternatives

üí° AVANTAGES DES BUILT-INS :
‚úÖ Performance optimis√©e (code C)
‚úÖ Disponibilit√© imm√©diate
‚úÖ Comportement standardis√©  
‚úÖ Gestion d'erreurs int√©gr√©e
‚úÖ Compatibilit√© multi-types

üö® BONNES PRATIQUES :
‚úÖ Pr√©f√©rer built-ins aux loops manuels
‚úÖ Combiner pour plus de puissance
‚úÖ Attention √† eval()/exec() (s√©curit√©)
‚úÖ Type checking avec isinstance()
‚úÖ Gestion des exceptions
‚úÖ Documentation du comportement

‚ö° PERFORMANCES :
‚Ä¢ Built-ins g√©n√©ralement plus rapides
‚Ä¢ Comprehensions souvent meilleures que map/filter
‚Ä¢ any()/all() avec short-circuit
‚Ä¢ min()/max() plus rapides que sorted()
‚Ä¢ enumerate() plus rapide que range(len())

üéØ PATTERNS COURANTS :
‚Ä¢ enumerate() pour index + valeur
‚Ä¢ zip() pour donn√©es parall√®les
‚Ä¢ all()/any() pour validation
‚Ä¢ sorted() avec key personnalis√©e
‚Ä¢ isinstance() pour polymorphisme
‚Ä¢ getattr() avec d√©fauts

üîß DEBUGGING ET INTROSPECTION :
‚Ä¢ dir() pour explorer objets
‚Ä¢ type() et isinstance() pour typage
‚Ä¢ vars() pour variables
‚Ä¢ callable() pour fonctions
‚Ä¢ hasattr() pour attributs

üéâ F√©licitations ! Fonctions built-in ma√Ætris√©es !
üí° Prochaine √©tape : Gestion des erreurs et exceptions !
üìö Built-ins ma√Ætris√©es, g√©rez les erreurs !
""")

print("\n" + "=" * 70)
print("üéØ FIN DU GUIDE - FONCTIONS BUILT-IN MA√éTRIS√âES !")
print("=" * 70)
